;;; fluids-3.xtm --

;; Author: Ben Swift and Joseph Penington
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;;

;;; Code:

(sys:load "libs/core/adt.xtm")

(bind-val CELL_SOLID i32 1)
(bind-val CELL_FLUID i32 0)

(bind-val SOLID_BOX i64 1)
(bind-val SOLID_SPHERE i64 2)

(bind-func sgn
  (lambda (n:double)
    (convert
     (cond ((< n 0) -1)
           ((> n 0) 1)
           (else 0))
             i32)))

(bind-func nsgn
  (lambda (n:double)
    (convert (if (> n 0) 1 -1) i32)))

(bind-func length
  (lambda (x:double y:double)
    (sqrt (+ (* x x) (* y y)))))

(bind-func cubicPulse
  (lambda (x:double)
    (set! x (min (fabs x) 1.))
    (- 1. (* x x (- 3. (* 2. x))))))

(bind-func rotate
    (lambda (x:double* y:double* phi:double)
      (let ((tmpX (pref x 0)) (tmpY (pref y 0)))
        (pset! x 0 (+ (* (cos phi) tmpX) (* (sin phi) tmpY)))
        (pset! y 0 (+ (* (sin phi) tmpX -1.) (* (cos phi) tmpY)))
        )))

(bind-func triangleOccupancy
  (lambda (out1:double in:double out2:double)
    (/ (* 0.5 in in) (* (- out1 in) (- out2 in)))))

(bind-func trapezoidOccupancy
  (lambda (out1:double out2:double in1:double in2:double)
    (* 0.5 (- (/ (* -1. in1) (- out1 in1)) (/ in2 (- out2 in2))))))

(bind-func occupancy
  (lambda (d11:double d12:double d21:double d22:double)
    (let ((ds:|4,double|* (alloc)) (b:i32 0) (i 3))
      (afill! ds d11 d12 d22 d21)
      (while (>= i 0)
        (set! b (bitwise-or
                 (bitwise-shift-left b 1)
                 (convert (if (< (aref ds i) 0.) 1. 0.) i32)))
        (set! i (- i 1)))
      (cond
        ((= b #x0)
          0.)
        ((= b #x1)
          (triangleOccupancy d21 d11 d12))
        ((= b #x2)
          (triangleOccupancy d11 d12 d22))
        ((= b #x4)
          (triangleOccupancy d12 d22 d21))
        ((= b #x8)
          (triangleOccupancy d22 d21 d11))

        ((= b #xE)
          (- 1. (triangleOccupancy (* -1. d21) (* -1. d11) (* -1. d12))))
        ((= b #xD)
          (- 1. (triangleOccupancy (* -1. d11) (* -1. d12) (* -1. d22))))
        ((= b #xB)
          (- 1. (triangleOccupancy (* -1. d12) (* -1. d22) (* -1. d21))))
        ((= b #x7)
          (- 1. (triangleOccupancy (* -1. d22) (* -1. d21) (* -1. d11))))

        ((= b #x3)
          (trapezoidOccupancy d21 d22 d11 d12))
        ((= b #x6)
          (trapezoidOccupancy d11 d21 d12 d22))
        ((= b #x9)
          (trapezoidOccupancy d12 d22 d11 d21))
        ((= b #xC)
          (trapezoidOccupancy d11 d12 d21 d22))

        ((= b #x5)
          (+ (triangleOccupancy d11 d12 d22)
            (triangleOccupancy d22 d21 d11)))
        ((= b #xA)
          (+ (triangleOccupancy d21 d11 d12)
            (triangleOccupancy d12 d22 d21)))
        ((= b #xF)
          1.))
    )))

(bind-type SolidBody <double,double,double,double,double,double,double,double,i64>
    (constructor? . #f)
    "0 - x Position
    1 - y Position
    2 - x Scale
    3 - y Scale
    4 - theta rotation
    5 - x Velocity
    6 - y Velocity
    7 - Angular Velocity
    8 - Shape ")

(bind-func SolidBox
  (lambda (x:double y:double sx:double sy:double t:double vx:double vy:double vt:double)
    (let ((sb:SolidBody* (alloc)))
      (tfill! sb x y sx sy t vx vy vt SOLID_BOX)
      sb)))

(bind-func SolidSphere
  (lambda (x:double y:double s:double t:double vx:double vy:double vt:double)
    (let ((sb:SolidBody* (alloc)))
      (tfill! sb x y s s t vx vy vt SOLID_SPHERE)
      sb)))

(bind-func globalToLocal
  (lambda (sb:SolidBody* x:double* y:double*)
    (pset! x 0 (- (pref x 0) (tref sb 0)))
    (pset! y 0 (- (pref y 0) (tref sb 1)))
    (rotate x y (* -1. (tref sb 4)))
    (pset! x 0 (/ (tref sb 2) (pref x 0)))
    (pset! y 0 (/ (tref sb 3) (pref y 0)))
    ))

(bind-func localToGlobal
  (lambda (sb:SolidBody* x:double* y:double*)
    (pset! x 0 (* (tref sb 2) (pref x 0)))
    (pset! y 0 (* (tref sb 3) (pref y 0)))
    (rotate x y (tref sb 4))
    (pset! x 0 (+ (pref x 0) (tref sb 0)))
    (pset! y 0 (+ (pref y 0) (tref sb 1)))
    ))

(bind-func velocityX
  (lambda (sb:SolidBody* x:double y:double)
    (+ (* (- (tref sb 1) y) (tref sb 7)) (tref sb 5))))

(bind-func velocityY
  (lambda (sb:SolidBody* x:double y:double)
    (+ (* (- x (tref sb 0)) (tref sb 7)) (tref sb 6))))

(bind-func velocity
  (lambda (sb:SolidBody* vx:double* vy:double* x:double y:double)
    (pset! vx 0 (velocityX sb x y))
    (pset! vy 0 (velocityY sb x y))))

(bind-func update
  (lambda (sb:SolidBody* timestep)
    (tset! sb 0 (+ (* (tref sb 5) timestep) (tref sb 0)))
    (tset! sb 1 (+ (* (tref sb 6) timestep) (tref sb 1)))
    (tset! sb 4 (+ (* (tref sb 7) timestep) (tref sb 4)))
    ))

(bind-func distance
  (lambda (sb:SolidBody* x:double y:double)
    (cond
      ((= (tref sb 8) SOLID_BOX)
        (set! x (- x (tref sb 0)))
        (set! y (- y (tref sb 1)))
        (let ((xp:double* (alloc)) (yp:double* (alloc)))
        (pset! xp 0 x)
        (pset! yp 0 y)
        (rotate xp yp (* -1. (tref sb 4)))
        (set! x (pref xp 0))
        (set! y (pref yp 0))
        (let ((dx (- (fabs x) (* (tref sb 2) 0.5)))
              (dy (- (fabs y) (* (tref sb 3) 0.5))))
            (if (or (>= dx 0.) (>= dy 0.))
              (length (max dx 0.0) (max dy 0.0))
              (max dx dy)))))
      ((= (tref sb 8) SOLID_SPHERE)
        (- (length (- x (tref sb 0)) (- y (tref sb 1))) (* 0.5 (tref sb 2)))))))

(bind-func closestSurfacePoint
  (lambda (sb:SolidBody* x:double* y:double*)
    (cond
      ((= (tref sb 8) SOLID_BOX)
        (pset! x 0 (- (pref x 0) (tref sb 0)))
        (pset! y 0 (- (pref y 0) (tref sb 1)))
        (rotate x y (* -1. (tref sb 4)))
        (let ((dx (- (fabs (pref x 0)) (* (tref sb 2) 0.5)))
              (dy (- (fabs (pref y 0)) (* (tref sb 3) 0.5))))
            (if (> dx dy)
              (pset! x 0 (* (convert (nsgn (pref x 0))) 0.5 (tref sb 2)))
              (pset! y 0 (* (convert (nsgn (pref y 0))) 0.5 (tref sb 3))))
            (rotate x y (tref sb 4))
            (pset! x 0 (+ (pref x 0) (tref sb 0))))
            (pset! y 0 (+ (pref y 0) (tref sb 1))))
        ((= (tref sb 8) SOLID_SPHERE)
          (globalToLocal sb x y)
          (let ((r (length (pref x 0) (pref y 0))))
          (if (< r  1e-4)
            (begin
              (pset! x 0 0.5)
              (pset! y 0 0.))
            (begin
              (pset! x 0 (/ (pref x 0) (* 2.0 r)))
              (pset! y 0 (/ (pref y 0) (* 2.0 r)))))
          (localToGlobal sb x y))))
          void))

(bind-func distanceNormal
  (lambda (sb:SolidBody* nx:double* ny:double* x:double y:double)
    (let ((xp:double* (alloc)) (yp:double* (alloc)))
      (pset! xp 0 x)
      (pset! yp 0 y)
      (cond
        ((= (tref sb 8) SOLID_BOX)
          (pset! xp 0 (- (pref xp 0) (tref sb 0)))
          (pset! yp 0 (- (pref yp 0) (tref sb 1)))
            (rotate xp yp (* -1. (tref sb 4)))
            (set! x (pref xp 0))
            (set! y (pref yp 0))
            (if (> (- (fabs x) (* 0.5 (tref sb 2))) (- (fabs y) (* 0.5 (tref sb 3))))
              (begin
                (pset! nx 0 (convert (nsgn x)))
                (pset! ny 0 0.))
              (begin
                (pset! ny 0 (convert (nsgn y)))
                (pset! nx 0 0.)))
            (rotate nx ny (tref sb 4)))
          ((= (tref sb 8) SOLID_SPHERE)
            (set! x (- x (tref sb 0)))
            (set! y (- y (tref sb 1)))
            (let ((r:double (length x y)))
              (if (< r 1e-4)
                (begin
                  (pset! nx 0 1.)
                  (pset! ny 0 0.))
                (begin
                  (pset! nx 0 (/ x r))
                  (pset! ny 0 (/ y r)))))))
                  void)))


(bind-type FluidQuantity <double*,double*,i32,i32,double,double,double,double*,double*,i32*,i32*,i32*,double*,double*>
  (constructor? . #f)
  "0 - fluid data
  1  - fluid data (double-buffer)
  2  - grid width
  3  - grid height
  4  - x offset
  5 - y offset
  6 - grid cell height
  7  - x normal
  8  - y normal
  9  - cell type
  10  - index of closest body
  11 - mask auxiliary array
  12 - phi
  13 - volume")

(bind-func FluidQuantity
  (lambda (w h ox oy hx)
    (let ((fq:FluidQuantity* (alloc))
          (src:double* (alloc (* w h)))
          (dst:double* (alloc (* w h)))
          (xNormal:double* (alloc (* w h)))
          (yNormal:double* (alloc (* w h)))
          (cell:i32* (alloc (* w h)))
          (body:i32* (alloc (* w h)))
          (mask:i32* (alloc (* w h)))
          (phi:double* (alloc (* (+ w 1) (+ h 1))))
          (volume:double* (alloc (* w h)))
          (i:i32 0))
          (dotimes (i (* w h))
            (pset! cell i CELL_FLUID)
            (pset! volume i 1.))
      (tfill! fq src dst w h ox oy hx xNormal yNormal cell body mask phi volume)
      fq)))

(bind-func FluidQuantity_h
  (lambda (w h ox oy hx)
    (let ((fq:FluidQuantity* (halloc))
          (src:double* (halloc (* w h)))
          (dst:double* (halloc (* w h)))
          (xNormal:double* (alloc (* w h)))
          (yNormal:double* (alloc (* w h)))
          (cell:i32* (halloc (* w h)))
          (body:i32* (halloc (* w h)))
          (mask:i32* (halloc (* w h)))
          (phi:double* (halloc (* (+ w 1) (+ h 1))))
          (volume:double* (halloc (* w h)))
          (i:i32 0))
          (dotimes (i (* w h))
            (pset! cell i CELL_FLUID)
            (pset! volume i 1.))
      (tfill! fq src dst w h ox oy hx xNormal yNormal cell body mask phi volume)
      fq)))

(bind-func FluidQuantity_free
  "free a halloc'ed FluidQuantity created with FluidQuantity_h"
  (lambda (fq:FluidQuantity*)
    (free (tref fq 0))
    (free (tref fq 1))
    (free fq)))

(bind-func sum
  (lambda (fq:FluidQuantity*)
    (let ((running_sum 0.)
          (i 0))
      (dotimes (i (convert (* (tref fq 2) (tref fq 3))))
        (set! running_sum (+ running_sum (pref (tref fq 0) i))))
      running_sum)))

(bind-func lerp
  (lambda (a:double b:double x:double)
    (+ (* a (- 1. x)) (* b x))))

(bind-func cerp
  (lambda (a b c d x)
    (let ((xsq (* x x)) (xcu (* x xsq))
          (minV (min a (min b (min c (min d x)))))
          (maxV (max a (max b (max c (max d x)))))
          (t
            (+ (* a (- (+ 0.0 (* 1.0 xsq)) (+ (* 0.5 x) (* 0.5 xcu))))
               (* b (- (+ 1.0 (* 0.0 x) (* 1.5 xcu)) (* 2.5 xsq)))
               (* c (- (+ 0.0 (* 0.5 x) (* 2.0 xsq)) (* 1.5 xcu)))
               (* d (- (+ 0.0 (* 0.0 x) (* 0.5 xcu)) (* 0.5 xsq))))))
               (min (max t minV) maxV))))

(bind-func at
  (lambda (fq:FluidQuantity* x y)
    (pref (tref fq 0) (+ (* y (tref fq 2)) x))))

(bind-func at
  (lambda (fq:FluidQuantity* x y)
    (pref-ptr (tref fq 0) (+ (* y (tref fq 2)) x))))

(bind-func volume
  (lambda (fq:FluidQuantity* x:i32 y:i32)
    (pref (tref fq 13) (+ x (* y (tref fq 2))))))

(bind-func cerp
  "Cubic intERPolate on grid at coordinates (x, y).
   Coordinates will be clamped to lie in simulation domain"
  (lambda (fq:FluidQuantity* x:double y:double)
    (let ((ox (tref fq 4)) (oy (tref fq 5)) (w:i32 (tref fq 2)) (h:i32 (tref fq 3)))
      (set! x (min (max (- x ox) 0.) (- (convert w) 1.001)))
      (set! y (min (max (- y oy) 0.) (- (convert h) 1.001)))
      (let ((ix (convert x i32))
            (iy (convert y i32)))
        (set! x (- x (convert ix)))
        (set! y (- y (convert iy)))
        (let ((x0 (max (- ix 1) 0)) (x1 ix) (x2 (+ ix 1)) (x3 (min (+ ix 2) (- w 1)))
              (y0 (max (- iy 1) 0)) (y1 iy) (y2 (+ iy 1)) (y3 (min (+ iy 2) (- h 1))))
          (let ((q0 (cerp:[double,double,double,double,double,double]*
                     (at:[double,FluidQuantity*,i32,i32]* fq x0 y0)
                     (at:[double,FluidQuantity*,i32,i32]* fq x1 y0)
                     (at:[double,FluidQuantity*,i32,i32]* fq x2 y0)
                     (at:[double,FluidQuantity*,i32,i32]* fq x3 y0) x))
                (q1 (cerp:[double,double,double,double,double,double]*
                     (at:[double,FluidQuantity*,i32,i32]* fq x0 y1)
                     (at:[double,FluidQuantity*,i32,i32]* fq x1 y1)
                     (at:[double,FluidQuantity*,i32,i32]* fq x2 y1)
                     (at:[double,FluidQuantity*,i32,i32]* fq x3 y1) x))
                (q2 (cerp:[double,double,double,double,double,double]*
                     (at:[double,FluidQuantity*,i32,i32]* fq x0 y2)
                     (at:[double,FluidQuantity*,i32,i32]* fq x1 y2)
                     (at:[double,FluidQuantity*,i32,i32]* fq x2 y2)
                     (at:[double,FluidQuantity*,i32,i32]* fq x3 y2) x))
                (q3 (cerp:[double,double,double,double,double,double]*
                     (at:[double,FluidQuantity*,i32,i32]* fq x0 y3)
                     (at:[double,FluidQuantity*,i32,i32]* fq x1 y3)
                     (at:[double,FluidQuantity*,i32,i32]* fq x2 y3)
                     (at:[double,FluidQuantity*,i32,i32]* fq x3 y3) x)))
            (let ((k (cerp:[double,double,double,double,double,double]* q0 q1 q2 q3 y)))
              (cerp:[double,double,double,double,double,double]* q0 q1 q2 q3 y))))))))

(bind-func lerp
  "Linear intERPolate on grid at coordinates (x, y).
  Coordinates will be clamped to lie in simulation domain"
  (lambda (fq:FluidQuantity* x:double y:double)
    (let ((ox (tref fq 4)) (oy (tref fq 5)) (w:i32 (tref fq 2)) (h:i32 (tref fq 3)))
    (set! x (min (max (- x ox) 0.) (- (convert w) 1.001)))
    (set! y (min (max (- y oy) 0.) (- (convert h) 1.001)))
    (let ((ix (convert x i32))
          (iy (convert y i32)))
      (set! x (- x (convert ix)))
      (set! y (- y (convert iy)))
      (let ((x00 (at:[double,FluidQuantity*,i32,i32]* fq (+ ix 0) (+ iy 0)))
            (x01 (at:[double,FluidQuantity*,i32,i32]* fq (+ ix 0) (+ iy 1)))
            (x10 (at:[double,FluidQuantity*,i32,i32]* fq (+ ix 1) (+ iy 0)))
            (x11 (at:[double,FluidQuantity*,i32,i32]* fq (+ ix 1) (+ iy 1))))
         (lerp:[double,double,double,double]*
         (lerp:[double,double,double,double]* x00 x10 x)
         (lerp:[double,double,double,double]* x01 x11 x)
         y))))))

(bind-func rungeKutta3
  (lambda (fq:FluidQuantity* xp:double* yp:double* timestep u:FluidQuantity* v:FluidQuantity*)
    (let ((hx (tref fq 6)) (x (pref xp 0)) (y (pref yp 0))
      (firstU (/ (lerp u x y) hx))
      (firstV (/ (lerp v x y) hx))
        (midX (- x (* 0.5 timestep firstU)))
        (midY (- y (* 0.5 timestep firstV)))
        (midU (/ (lerp u midX midY) hx))
        (midV (/ (lerp v midX midY) hx))
            (lastX (- x (* 0.75 timestep midU)))
            (lastY (- y (* 0.75 timestep midV)))
            (lastU (lerp u lastX lastY))
            (lastV (lerp v lastX lastY)))
                  (pset! xp 0 (- x (* timestep (+ (* (/ 2. 9.) firstU) (* (/ 3. 9.) midU) (* (/ 4. 9.) lastU)))))
                  (pset! yp 0 (- y (* timestep (+ (* (/ 2. 9.) firstV) (* (/ 3. 9.) midV) (* (/ 4. 9.) lastV)))))
                  void)))

(bind-func euler
  (lambda (fq:FluidQuantity* x:double* y:double* timestep u:FluidQuantity* v:FluidQuantity*)
    (let ((uVel (/ (lerp u (pref x 0) (pref y 0)) (tref fq 6)))
          (vVel (/ (lerp v (pref x 0) (pref y 0)) (tref fq 6))))
      (pset! x 0 (- (pref x 0) (* uVel timestep)))
      (pset! y 0 (- (pref y 0) (* vVel timestep))))
    void))

(bind-func flip
  (lambda (fq:FluidQuantity*)
    (let ((tmp:double* null))
      (set! tmp (tref fq 0))
      (tset! fq 0 (tref fq 1))
      (tset! fq 1 tmp))))

(bind-func src
  (lambda (fq:FluidQuantity*)
    (tref fq 0)))

(bind-func backProject
  (lambda (fq:FluidQuantity* x:double* y:double* bodies:List{SolidBody*}*)
    (let ((rx (min (max (convert (- (pref x 0) (tref fq 4)) i32) (convert 0 i32)) (convert (- (tref fq 2) 1) i32)))
          (ry (min (max (convert (- (pref y 0) (tref fq 5)) i32) (convert 0 i32)) (convert (- (tref fq 3) 1) i32)))
          (cell (tref fq 9)) (w (tref fq 2)) (body (tref fq 10)) (idx (+ rx (* ry w))))
      (if (<> (pref cell idx) CELL_FLUID)
        (begin
          (pset! x 0 (* (- (pref x 0) (tref fq 4)) (tref fq 6)))
          (pset! y 0 (* (- (pref y 0) (tref fq 5)) (tref fq 6)))
          (closestSurfacePoint (nth bodies 0) x y)
          (pset! x 0 (+ (/ (pref x 0) (tref fq 6)) (tref fq 4)))
          (pset! y 0 (+ (/ (pref y 0) (tref fq 6)) (tref fq 5 )))))
        void)))

(bind-func advect
  "Advect grid in velocity field u, v with given timestep"
  (lambda (fq timestep u v bodies)
    (let ((ix:i32 0) (idx 0)
          (iy:i32 0) (idy 0)
          (x:double* (alloc))
          (y:double* (alloc))
          (cell (tref fq 9)))
      (dotimes (iy (tref fq 3))
        (dotimes (ix (tref fq 2))
          (if (= (pref cell idx) CELL_FLUID)
          (begin
          (pset! x 0 (+ (convert ix) (tref fq 4)))
          (pset! y 0 (+ (convert iy) (tref fq 5)))
          ;; First component: Integrate in time
          (rungeKutta3 fq x y timestep u v)
          ;; Second component: Interpolate from grid
          (backProject fq x y bodies)
          (pset! (tref fq 1) idx (cerp:[double,FluidQuantity*,double,double]* fq (pref x 0) (pref y 0)))))
          (set! idx (+ idx 1))))
    void)))

(bind-func fillSolidFields
  (lambda (fq:FluidQuantity* bodies)
    (if (not (null? bodies))
        (begin
        (let ((iy:i32 0) (idx:i32 0) (ix:i32 0) (body (tref fq 10)) (cell (tref fq 9)) (phi (tref fq 12))
              (normalX (tref fq 7)) (normalY (tref fq 8)) (x 0.) (y 0.) (w (tref fq 2)) (h (tref fq 3)) (volume (tref fq 13)))

          (dotimes (iy (+ h 1))
            (dotimes (ix (+ w 1))
              (set! x (* (- (+ (convert ix) (tref fq 4)) 0.5) (tref fq 6)))
              (set! y (* (- (+ (convert iy) (tref fq 5)) 0.5) (tref fq 6)))
              (pset! phi idx (distance (car bodies) x y))
              (let ((remaining_bodies (cdr bodies)))
                (while (not (null? remaining_bodies))
                  (pset! phi idx (min (pref phi idx) (distance (car remaining_bodies) x y)))
                  (set! remaining_bodies (cdr remaining_bodies))))
              (set! idx (+ 1 idx))))

          (set! iy 0)
          (set! ix 0)
          (set! idx 0)

          (dotimes (iy h)
            (dotimes (ix w)
              (set! x (* (+ (convert ix double) (tref fq 4)) (tref fq 6)))
              (set! y (* (+ (convert iy double) (tref fq 5)) (tref fq 6)))
              (pset! body idx 0)

              (let ((d (distance (car bodies) x y)) ;; distance to "head" of bodies list
                    (remaining_bodies (cdr bodies)) ;; pointer to "rest" of bodies list
                    (i:i32 1)
                    (id 0.))
                (while (not (null? remaining_bodies))
                  (set! id (distance (car remaining_bodies) x y))
                  (if (< id d)
                      (begin
                        (pset! body idx (convert i i32))
                        (set! d id)))
                  ;; "recurse" down the list
                  (set! i (+ i 1))
                  (set! remaining_bodies (cdr remaining_bodies))))


                (let ((idxp (+ ix (* iy (+ w 1)))))
                  (pset! volume idx (- 1. (occupancy
                                            (pref phi idxp) (pref phi (+ idxp 1))
                                            (pref phi (+ idxp w 1)) (pref phi (+ idxp w 2))))))
                (if (< (pref volume idx) 0.01)
                  (pset! volume idx 0.))

          (let ((normxp:double* (alloc)) (normyp:double* (alloc)))
            (pset! normxp 0 (pref normalX idx))
            (pset! normyp 0 (pref normalY idx))
            (distanceNormal (nth bodies (convert (pref body idx))) normxp normyp x y)
            (pset! normalX idx (pref normxp 0))
            (pset! normalY idx (pref normyp 0)))

            (if (= (pref volume idx) 0.)
              (pset! cell idx CELL_SOLID)
              (pset! cell idx CELL_FLUID))

            (set! idx (+ 1 idx)))))))
        void))

(bind-func addInFlow
  "Sets fluid quantity inside the given rect to value `v'"
  (lambda (fq:FluidQuantity* x0 y0 x1 y1 v)
    (let ((hx (tref fq 6))
          (ix0 (convert (- (/ x0 hx) (tref fq 4)) i32))
          (iy0 (convert (- (/ y0 hx) (tref fq 5)) i32))
          (ix1 (convert (- (/ x1 hx) (tref fq 4)) i32))
          (iy1 (convert (- (/ y1 hx) (tref fq 5)) i32))
          (y (max iy0 0)))
      ;; Sets fluid quantity inside the given rect to value `v'
      (while (< y (min iy1 (convert (tref fq 3))))
      (let ((x (max ix0 0)))
        (while (< x (min ix1 (convert (tref fq 3))))
          (let ((l (length (/ (- (* 2. (+ (convert x) .5) hx) (+ x0 x1)) (- x1 x0))
                           (/ (- (* 2. (+ (convert y) .5) hx) (+ y0 y1)) (- y1 y0))))
                (vi (* v (cubicPulse l))))
          (if (< (fabs (pref (tref fq 0) (+ x (* y (tref fq 2)))))
                 (fabs vi))
                 (begin
              (pset! (tref fq 0)
                     (+ x (* y (tref fq 2)))
                     vi))))
          (set! x (+ x 1)))
        (set! y (+ y 1))))
      void)))

(bind-func fillSolidMask
  (lambda (fq:FluidQuantity*)
    (let ((y 1) (x 1) (h (tref fq 3)) (w (tref fq 2)) (mask (tref fq 11)) (cell (tref fq 9))
      (normalX (tref fq 7)) (normalY (tref fq 8)))
        (while (< y (- h 1))
          (set! x 1)
          (while (< x (- w 1))
            (let ((idx (+ x (* y w))))
              (if (not (= (pref (tref fq 9) idx) CELL_FLUID))
                (begin
                (let ((nx (pref normalX idx))
                      (ny (pref normalY idx)))
                    (pset! mask idx 0)
                    (if (and (<> nx 0.)
                             (<> (pref cell (+ idx (sgn nx))) CELL_FLUID))
                      (pset! mask idx (bitwise-or (pref mask idx) 1)))
                    (if (and (<> ny 0.)
                             (<> (pref cell (+ idx (* (convert w) (sgn ny)))) CELL_FLUID))
                      (pset! mask idx (bitwise-or (pref mask idx) 2)))))))
                      (set! x (+ 1 x)))
                      (set! y (+ 1 y))))))

(bind-func extrapolateNormal
  (lambda (fq:FluidQuantity* idx)
    (let ((normalX (tref fq 7)) (normalY (tref fq 8))
          (nx (pref normalX idx)) (ny (pref normalY idx))
          (src (tref fq 0))
          (srcX (pref src (+ idx (sgn nx))))
          (srcY (pref src (+ idx (* (tref fq 2) (sgn ny))))))
      (/ (+ (* (fabs nx) srcX) (* (fabs ny) srcY)) (+ (fabs nx) (fabs ny))))))

(bind-func freeNeighbour
  (lambda (fq:FluidQuantity* idx:i32 border mask)
    (let ((fqmask:i32* (tref fq 11)) (cell (tref fq 9)))
      (pset! fqmask idx (bitwise-and (pref fqmask idx) mask))
      (if (and (<> (pref cell idx) CELL_FLUID) (= (pref fqmask idx) 0))
            (set! border (cons idx border)))
          border)))

(bind-func extrapolate
  (lambda (fq:FluidQuantity*)
    (fillSolidMask fq)
    (let ((border (list)) (y:i32 1) (x:i32 1) (idx:i32 0)
          (w:i32 (tref fq 2)) (h:i32 (tref fq 3)) (src (tref fq 0))
          (normalX (tref fq 7)) (normalY (tref fq 8)))
      (while (< y (- h 1))
        (set! x 1)
        (while (< x (- w 1))
          (set! idx (+ x (* w y)))
          (if (and (<> (pref (tref fq 9) idx) CELL_FLUID)
                   (= (pref (tref fq 11) idx) 0))
              (begin
              (set! border (cons idx border))))
          (set! x (+ 1 x)))
        (set! y (+ 1 y)))
        (while (not (null? border))
          (set! idx (car border))
          (set! border (cdr border))
          (pset! src idx (extrapolateNormal fq idx))
           (if (> (pref normalX (- idx 1)) 0.)
            (begin
            (set! border (freeNeighbour fq (- idx 1) border (convert 2 i32)))))
           (if (< (pref normalX (+ idx 1)) 0.)
            (begin
            (set! border (freeNeighbour fq (+ idx 1) border (convert 2 i32)))))
           (if (> (pref normalY (- idx w)) 0.)
            (begin
            (set! border (freeNeighbour fq (- idx w) border (convert 1 i32)))))
           (if (< (pref normalY (+ idx  w)) 0.)
            (begin
            (set! border (freeNeighbour fq (+ idx w) border (convert 1 i32)))))
          ))))

(bind-func getidx
  (lambda (fq:FluidQuantity* x:i32 y:i32)
    (+ (* (tref fq 2) y) x)))

(bind-type FluidSolver <FluidQuantity*,FluidQuantity*,FluidQuantity*,i32,i32,double,double,double*,double*,double*,double*,double*,double*,double*,double*,List{SolidBody*}*,FluidQuantity*,double,double,double,double,double*,double*}*>
  (constructor? . #f)
  "0 - density grid
  1 - u
  2 - v
  3 - width
  4 - height
  5 - grid cell height
  6 - gravity
  7 - right-hand side of pressure solve
  8 - pressure solution
  9 - auxiliary vector
  10 - search vector
  11 - preconditioner
  12 - matrix diagonal
  13 - matrix off-diagonals x
  14 - matrix off-diagonals y
  15 - Solid Bodies
  16 - temperature fluid quantity
  17 - density of air
  18 - density of soot
  19 - diffusion rate of heat
  20 - ambient temperature in K
  21 - uDensity
  22 - vDensity
  ")

(bind-func FluidSolver
  (lambda (w h cBodies rhoAir rhoSoot diffusion)
    (let ((hx (/ 1. (convert (min w h))))
          (fs:FluidSolver* (alloc))
          (d (FluidQuantity w h 0.5 0.5 hx))
          (u (FluidQuantity (+ w 1) h 0.0 0.5 hx))
          (v (FluidQuantity w (+ h 1) 0.5 0.0 hx))
          (r:double* (alloc (* w h)))
          (p:double* (alloc (* w h)))
          (z:double* (alloc (* w h)))
          (s:double* (alloc (* w h)))
          (aDiag:double* (alloc (* w h)))
          (aPlusX:double* (alloc (* w h)))
          (aPlusY:double* (alloc (* w h)))
          (precon:double* (alloc (* w h)))
          (t (FluidQuantity w h 0.5 0.5 hx))
          (tAmb 294.0)
          (g 9.81)
          (uDensity:double* (alloc (* (+ w 1) h)))
          (vDensity:double* (alloc (* w (+ h 1))))
          (i:i32 0))
      (dotimes (i (* w h))
        (pset! (tref t 0) i tAmb))
      (tfill! fs d u v w h hx g r p z s aDiag aPlusX aPlusY precon cBodies t rhoAir rhoSoot diffusion tAmb uDensity vDensity)
      fs)))

(bind-func FluidSolver_h
  (lambda (w h cBodies rhoAir rhoSoot diffusion)
    (let ((hx (/ 1. (convert (min w h))))
          (fs:FluidSolver* (alloc))
          (d (FluidQuantity_h w h 0.5 0.5 hx))
          (u (FluidQuantity_h (+ w 1) h 0.0 0.5 hx))
          (v (FluidQuantity_h w (+ h 1) 0.5 0.0 hx))
          (r:double* (halloc (* w h)))
          (p:double* (halloc (* w h)))
          (z:double* (halloc (* w h)))
          (s:double* (halloc (* w h)))
          (aDiag:double* (halloc (* w h)))
          (aPlusX:double* (halloc (* w h)))
          (aPlusY:double* (halloc (* w h)))
          (precon:double* (halloc (* w h)))
          (t (FluidQuantity_h w h 0.5 0.5 hx))
          (tAmb 294.0)
          (g 9.81)
          (uDensity:double* (halloc (* (+ w 1) h)))
          (vDensity:double* (halloc (* w (+ h 1))))
          (i:i32 0))
      (dotimes (i (* w h))
        (pset! (tref t 0) i tAmb))
      (tfill! fs d u v w h hx g r p z s aDiag aPlusX aPlusY precon cBodies t rhoAir rhoSoot diffusion tAmb uDensity vDensity)
      fs)))

(bind-func FluidSolver_free
  "free a halloc'ed FluidSolver created with FluidSolver_h"
  (lambda (fs:FluidSolver*)
    (FluidQuantity_free (tref fs 0))
    (FluidQuantity_free (tref fs 1))
    (FluidQuantity_free (tref fs 1))
    (free (tref fs 7))
    (free (tref fs 8))
    (free fs)))

;; accessor functions for pointers to the raw data

(bind-func fsd
  (lambda (fs:FluidSolver*)
    (tref (tref fs 0) 0)))

(bind-func fsu
  (lambda (fs:FluidSolver*)
    (tref (tref fs 1) 0)))

(bind-func fsv
  (lambda (fs:FluidSolver*)
    (tref (tref fs 2) 0)))

(bind-func buildRhs
  "Builds the pressure right hand side as the negative divergence"
  (lambda (fs:FluidSolver*)
    (let ((scale (/ 1. (tref fs 5)))
          (x 0) (y 0) (idx 0)
          (d (tref fs 0)) (u (tref fs 1)) (v (tref fs 2))
          (w (tref fs 3)) (h (tref fs 4)) (hx (tref fs 5))
          (cell (tref fs 9)) (body (tref fs 10))
          (bodies (tref fs 15)) (r (tref fs 7)))

      (while (< y h)
        (set! x 0)
        (while (< x w)
          (if (= (pref (tref d 9) idx) CELL_FLUID)
            (begin
            (pset! r idx
                       (* -1. scale (- (+ (* (volume u (+ x 1) y) (at:[double,FluidQuantity*,i32,i32]* u (+ x 1) y))
                                          (* (volume v x (+ y 1)) (at:[double,FluidQuantity*,i32,i32]* v x (+ y 1))))
                                       (+ (* (volume u x y) (at:[double,FluidQuantity*,i32,i32]* u x y))
                                          (* (volume v x y) (at:[double,FluidQuantity*,i32,i32]* v x y))))))
            (let ((vol (volume d x y)))
              (if (not (null? bodies))
                (begin
                  (if (> x 0)
                    (pset! r idx (- (pref r idx) (* (- (volume u x y) vol) (velocityX (nth bodies 0) (* (convert x) hx) (* (+ (convert y) 0.5) hx))))))
                  (if (> y 0)
                    (pset! r idx (- (pref r idx) (* (- (volume v x y) vol) (velocityY (nth bodies 0) (* (+ (convert x) 0.5) hx) (* (convert y) hx))))))
                  (if (< x (- w 1))
                    (pset! r idx (+ (pref r idx) (* (- (volume u (+ x 1) y) vol) (velocityX (nth bodies 0) (* (+ (convert x) 1.) hx) (* (+ (convert y) 0.5) hx))))))
                  (if (< y (- h 1))
                    (pset! r idx (+ (pref r idx) (* (- (volume v x (+ y 1)) vol) (velocityY (nth bodies 0) (* (+ (convert x) 0.5) hx) (* (+ (convert y) 1.) hx))))))))))

          (pset! (tref fs 7) idx 0.))
          (set! x (+ x 1))
          (set! idx (+ idx 1)))
          (set! y (+ 1 y))))))

(bind-func computeDensities
  (lambda (fs:FluidSolver*)
    (let ((densityAir (tref fs 17)) (densitySoot (tref fs 18))
          (alpha (/ (- densitySoot densityAir) densityAir))
          (uDensity (tref fs 21)) (vDensity (tref fs 22))
          (x 0) (y 0) (w (tref fs 3)) (h (tref fs 4)) (density 0.0)
          (d (tref fs 0)) (u (tref fs 1)) (v (tref fs 2)) (t (tref fs 16))
          (a:i32 0) (b:i32 0))
          (dotimes (a (* (+ 1 w) h))
            (pset! uDensity a 0.0))
          (dotimes (b (* w (+ 1 h)))
            (pset! vDensity b 0.0))
          (dotimes (y h)
            (dotimes (x w)
              (set! density (/ (* densityAir (tref fs 20) (+ 1.0 (* alpha (at:[double,FluidQuantity*,i32,i32]* d x y)))) (at:[double,FluidQuantity*,i32,i32]* t x y)))
              (set! density (max density (* 0.05 densityAir)))
              (pset! uDensity (getidx u x y) (+ (pref uDensity (getidx u x y)) (* 0.5 density)))
              (pset! vDensity (getidx v x y) (+ (pref vDensity (getidx v x y)) (* 0.5 density)))
              (pset! uDensity (getidx u (+ 1 x) y) (+ (pref uDensity (getidx u (+ 1 x) y)) (* 0.5 density)))
              (pset! vDensity (getidx v x (+ y 1)) (+ (pref vDensity (getidx v x (+ y 1))) (* 0.5 density))))
              ))))

(bind-func buildPressureMatrix
  (lambda (fs:FluidSolver* timestep)
    (let ((scale (/ timestep (* (tref fs 17) (tref fs 5) (tref fs 5)))) (factor 0.)
          (y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4)) (a:i32 0) (d (tref fs 0))
          (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14))
           (u (tref fs 1)) (v (tref fs 2)) (uDensity (tref fs 21)) (vDensity (tref fs 22)))

      (dotimes (a (* w h))
        (pset! aDiag a 0.)
        (pset! aPlusX a 0.)
        (pset! aPlusY a 0.))

      (dotimes (y h)
        (dotimes (x w)
        (if (= (pref (tref d 9) idx) CELL_FLUID)
          (begin
            (if (and (< x (- w 1)) (= (pref (tref d 9) (+ idx 1)) CELL_FLUID))
              (begin
              (set! factor (/ (* scale (volume u (+ x 1) y)) (pref uDensity (getidx u (+ 1 x) y))))
              (pset! aDiag idx (+ (pref aDiag idx) factor))
              (pset! aDiag (+ idx 1) (+ (pref aDiag (+ 1 idx)) factor))
              (pset! aPlusX idx (* -1. factor))))
            (if (and (< y (- h 1)) (= (pref (tref d 9) (+ idx w)) CELL_FLUID))
              (begin
              (set! factor (/ (* scale (volume v x (+ y 1))) (pref vDensity (getidx u x (+ 1 y)))))
              (pset! aDiag idx (+ (pref aDiag idx) factor))
              (pset! aDiag (+ idx w) (+ (pref aDiag (+ w idx)) factor))
              (pset! aPlusY idx (* -1. factor))))))
          (set! idx (+ idx 1))
          )))))

(bind-func buildHeatDiffusionMatrix
  (lambda (fs:FluidSolver* timestep)
    (let ((i:i32 0) (w (tref fs 3)) (h (tref fs 4))
          (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14))
          (d (tref fs 0)) (cell (tref d 9)) (scale (/ (* (tref fs 19) timestep) (* (tref fs 5) (tref fs 5))))
          (x 0) (y 0) (idx:i32 0))
      (dotimes (i (* w h))
        (pset! aDiag i 1.0)
        (pset! aPlusX i 0.0)
        (pset! aPlusY i 0.0))
        (dotimes (y h)
          (dotimes (x w)
            (if (= CELL_FLUID (pref cell idx))
              (begin
                (if (and (< x (- w 1)) (= (pref cell (+ 1 idx)) CELL_FLUID))
                  (begin
                    (pset! aDiag idx (+ (pref aDiag idx) scale))
                    (pset! aDiag (+ idx 1) (+ (pref aDiag (+ idx 1)) scale))
                    (pset! aPlusX idx (* -1. scale))))
                (if (and (< y (- h 1)) (= (pref cell (+ w idx)) CELL_FLUID))
                  (begin
                    (pset! aDiag idx (+ (pref aDiag idx) scale))
                    (pset! aDiag (+ idx w) (+ (pref aDiag (+ idx w)) scale))
                    (pset! aPlusY idx (* -1. scale))))
                ))
              (set! idx (+ 1 idx))))
        )))

(bind-func buildPreconditioner
  (lambda (fs:FluidSolver*)
    (let ((tau 0.97) (sigma 0.25)
          (y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4)) (d (tref fs 0))
          (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14)) (precon (tref fs 11)))
      (dotimes (y h)
        (dotimes (x w)
        (if (= (pref (tref d 9) idx) CELL_FLUID)
          (begin
          (let ((e (pref aDiag idx)))
            (if (and (> x 0) (= (pref (tref d 9) (- idx 1)) CELL_FLUID))
              (begin
                (let ((px (* (pref aPlusX (- idx 1)) (pref precon (- idx 1))))
                      (py (* (pref aPlusY (- idx 1)) (pref precon (- idx 1)))))
                    (set! e (- e (+ (* px px) (* tau px py)))))))
            (if (and (> y 0) (= (pref (tref d 9) (- idx w)) CELL_FLUID))
              (begin
                (let ((px (* (pref aPlusX (- idx w)) (pref precon (- idx w))))
                      (py (* (pref aPlusY (- idx w)) (pref precon (- idx w)))))
                    (set! e (- e (+ (* py py) (* tau px py)))))))

            (if (< e (* sigma (pref aDiag idx)))
              (set! e (pref aDiag idx)))

            (pset! precon idx (/ 1. (sqrt e))))))
            (set! idx (+ idx 1)))))))

(bind-func applyPreconditioner
  (lambda (fs:FluidSolver* dst:double* a:double*)
    (let ((y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4)) (d (tref fs 0))
    (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14)) (precon (tref fs 11)))
      (dotimes (y h)
        (dotimes (x w)
          (if (= (pref (tref d 9) idx) CELL_FLUID)
            (begin
            (let ((t (pref a idx)))
              (if (and (> x 0) (= (pref (tref d 9) (- idx 1)) CELL_FLUID))
                (set! t (- t (* (pref aPlusX (- idx 1)) (pref precon (- idx 1)) (pref dst (- idx 1))))))

              (if (and (> y 0) (= (pref (tref d 9) (- idx w)) CELL_FLUID))
                (set! t (- t (* (pref aPlusY (- idx w)) (pref precon (- idx w)) (pref dst (- idx w))))))

              (pset! dst idx (* t (pref precon idx))))))
              (set! idx (+ idx 1))))

      (set! y (- h 1))
      (set! idx (- (* w h) 1))

      (while (>= y 0)
      (set! x (- w 1))
        (while (>= x 0)
          (if (= (pref (tref d 9) idx) CELL_FLUID)
          (begin
          (let ((t (pref dst idx)))
          (if (and (< x (- w 1)) (= (pref (tref d 9) (+ idx 1)) CELL_FLUID))
              (set! t (- t (* (pref aPlusX idx) (pref precon idx) (pref dst (+ 1 idx))))))
          (if (and (< y (- h 1)) (= (pref (tref d 9) (+ idx w)) CELL_FLUID))
              (set! t (- t (* (pref aPlusY idx) (pref precon idx) (pref dst (+ w idx))))))

        (pset! dst idx (* t (pref precon idx))))))

        (set! x (- x 1))
        (set! idx (- idx 1)))
        (set! y (- y 1))))))

(bind-func dotProduct
  (lambda (fs:FluidSolver* a:double* b:double*)
    (let ((result 0.0) (i:i32 0) (w (tref fs 3)) (h (tref fs 4)))
      (dotimes (i (* w h))
        (set! result (+ result (* (pref a i) (pref b i)))))
      result)))

(bind-func matrixVectorProduct
  (lambda (fs:FluidSolver* dst:double* b:double*)
    (let ((y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4))
          (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14)) (precon (tref fs 11)))
      (dotimes (y h)
        (dotimes (x w)
          (let ((t (* (pref aDiag idx) (pref b idx))))
            (if (> x 0)
                (set! t (+ t (* (pref aPlusX (- idx 1)) (pref b (- idx 1))))))
            (if (> y 0)
                (set! t (+ t (* (pref aPlusY (- idx w)) (pref b (- idx w))))))
            (if (< x (- w 1))
                (set! t (+ t (* (pref aPlusX idx) (pref b (+ idx 1))))))
            (if (< y (- h 1))
                (set! t (+ t (* (pref aPlusY idx) (pref b (+ idx w))))))

            (pset! dst idx t)
            (set! idx (+ idx 1))))))))

(bind-func scaledAdd
  (lambda (fs:FluidSolver* dst:double* a:double* b:double* s:double)
    (let ((i:i32 0) (w (tref fs 3)) (h (tref fs 4))
    (d (tref fs 0)) (cell (tref d 9)))
      (dotimes (i (* w h))
      (if (= (pref cell i) CELL_FLUID)
        (pset! dst i (+ (pref a i) (* (pref b i ) s))))))))

(bind-func infinityNorm
  (lambda (fs:FluidSolver* a:double*)
    (let ((maxA 0.0) (i:i32 0) (w (tref fs 3)) (h (tref fs 4))
          (d (tref fs 0)) (cell (tref d 9)))
      (dotimes (i (* w h))
        (if (= (pref cell i) CELL_FLUID)
        (set! maxA (max maxA (fabs (pref a i))))))
        maxA)))

(bind-func project
  "Performs the pressure solve using Gauss-Seidel.
  The solver will run as long as it takes to get the relative error below
  a threshold, but will never exceed `limit' iterations"
  (lambda (fs:FluidSolver* limit:i32)
    (let ((maxDelta:double 1.)
          (iter:i32 0) (i:i32 0)
          (x:i32 0) (y:i32 0) (idx:i32 0)
          (w (tref fs 3)) (h (tref fs 4))
          (p (tref fs 8))
          (z (tref fs 9))
          (r (tref fs 7))
          (s (tref fs 10))
          (maxError (infinityNorm fs r)) (sigma 0.))
      (applyPreconditioner fs z r)
      (dotimes (i (* w h))
        (pset! s i (pref z i))
        (pset! p i 0.))
      (set! sigma (dotProduct fs z r))
      (while (and (> maxError 1e-5) (< iter limit))
        (matrixVectorProduct fs z s)
        (let ((alpha (/ sigma (dotProduct fs z s))))
          (scaledAdd fs p p s alpha)
          (scaledAdd fs r r z (* -1. alpha))
          (set! maxError (infinityNorm fs r))
          (if (> maxError 1e-5)
              (begin
                (applyPreconditioner fs z r)
                (let ((sigmaNew (dotProduct fs z r)))
                  (scaledAdd fs s z s (/ sigmaNew sigma))
                  (set! sigma sigmaNew))
                (set! iter (+ iter 1)))))))))

(bind-func applyPressure
  "Applies the computed pressure to the velocity field"
  (lambda (fs:FluidSolver* timestep)
    (let ((scale (/ timestep (* (tref fs 17) (tref fs 5))))
          (x 0) (y 0) (idx 0)
          (w (tref fs 3)) (h (tref fs 4))
          (d (tref fs 0))
          (u (tref fs 1))
          (v (tref fs 2))
          (p (tref fs 8))
          (uDensity (tref fs 21)) (vDensity (tref fs 22)))
      (dotimes (y h)
        (dotimes (x w)
          (if (= (pref (tref d 9) idx) CELL_FLUID)
            (begin
            ;; this is a bit messy - we could get around it by just
            ;; using different names for the ref/val `at' function
            ;; instead of using polymorphism
            (pset! (at:[double*,FluidQuantity*,i32,i32]* u x y) 0
                (- (at:[double,FluidQuantity*,i32,i32]* u x y) (/ (* scale (pref p idx)) (pref uDensity (getidx u x y)))))
            (pset! (at:[double*,FluidQuantity*,i32,i32]* u (+ x 1) y) 0
                (+ (at:[double,FluidQuantity*,i32,i32]* u (+ x 1) y) (/ (* scale (pref p idx)) (pref uDensity (getidx u (+ x 1) y)))))
            (pset! (at:[double*,FluidQuantity*,i32,i32]* v x y) 0
                (- (at:[double,FluidQuantity*,i32,i32]* v x y) (/ (* scale (pref p idx)) (pref vDensity (getidx v x y)))))
            (pset! (at:[double*,FluidQuantity*,i32,i32]* v x (+ y 1)) 0
                (+ (at:[double,FluidQuantity*,i32,i32]* v x (+ y 1)) (/ (* scale (pref p idx)) (pref vDensity (getidx v x (+ y 1))))))))
          (set! idx (+ idx 1)))))))

(bind-func addBuoyancy
  (lambda (fs:FluidSolver* timestep)
    (let ((alpha (/ (- (tref fs 18) (tref fs 17)) (tref fs 17)))
          (y 0) (x 0) (w (tref fs 3)) (h (tref fs 4))
          (d (tref fs 0)) (t (tref fs 16))
          (buoyancy 0.) (v (tref fs 2))
          (tAmb (tref fs 20)) (g (tref fs 6)))
      (dotimes (y h)
        (dotimes (x w)
          (set! buoyancy (* timestep g (- (* alpha (at:[double,FluidQuantity*,i32,i32]* d x y))
                                              (/ (- (at:[double,FluidQuantity*,i32,i32]* t x y) tAmb) tAmb))))
          (pset! (at:[double*,FluidQuantity*,i32,i32]* v x y) 0
                          (+ (at:[double,FluidQuantity*,i32,i32]* v x y) (* buoyancy 0.5)))
          (pset! (at:[double*,FluidQuantity*,i32,i32]* v x (+ 1 y)) 0
                          (+ (at:[double,FluidQuantity*,i32,i32]* v x (+ 1 y)) (* buoyancy 0.5)))
          )))))



(bind-func setBoundaryCondition
  (lambda (fs:FluidSolver*)
    (let ((d (tref fs 0)) (cell (tref d 9)) (body (tref d 10)) (u (tref fs 1)) (hx (tref fs 5))
          (y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4)) (v (tref fs 2)) (bodies (tref fs 15))
          (b null))
      (dotimes (y h)
        (dotimes (x w)
          (if (= (pref (tref d 9) idx) CELL_SOLID)
              (begin
                (set! b (nth bodies (convert (pref body idx))))
                (pset! (at:[double*,FluidQuantity*,i32,i32]* u x y)
                       0 (velocityX b (* (convert x) hx) (* (+ (convert y) 0.5) hx)))
                (pset! (at:[double*,FluidQuantity*,i32,i32]* v x y)
                       0 (velocityX b (* (+ (convert x) 0.5) hx) (* (convert y) hx)))
                (pset! (at:[double*,FluidQuantity*,i32,i32]* u (+ 1 x) y)
                       0 (velocityX b (* (+ (convert x) 1.0) hx) (* (+ (convert y) 0.5) hx)))
                (pset! (at:[double*,FluidQuantity*,i32,i32]* v x (+ 1 y))
                       0 (velocityX b (* (+ (convert x) 0.5) hx) (* (+ (convert y) 1.0) hx)))))
          (set! idx (+ 1 idx))))
      (set! x 0)
      (set! y 0)
      (while (< y h)
        (pset! (at:[double*,FluidQuantity*,i32,i32]* u 0 y) 0 0.)
        (pset! (at:[double*,FluidQuantity*,i32,i32]* u w y) 0 0.)
        (set! y (+ 1 y)))
      (while (< x w)
        (pset! (at:[double*,FluidQuantity*,i32,i32]* v x 0) 0 0.)
        (pset! (at:[double*,FluidQuantity*,i32,i32]* v x h) 0 0.)
        (set! x (+ 1 x))))))

(bind-func updatefs
  (lambda (fs:FluidSolver* timestep:double)
  (let ((i:i32 0) (h (tref fs 4)) (w (tref fs 3)) (x:i32 0) (y:i32 0) (idx:i32 0)
        (d (tref fs 0)) (u (tref fs 1)) (v (tref fs 2)) (t (tref fs 16))
        (bodies (tref fs 15)))
    (fillSolidFields d bodies)
    (fillSolidFields t bodies)
    (fillSolidFields u bodies)
    (fillSolidFields v bodies)

    (dotimes (i (* w h))
      (pset! (tref fs 7) i (pref (tref t 0) i)))
    (buildHeatDiffusionMatrix fs timestep)
    (buildPreconditioner fs)
    (project fs 2000)
    (set! i 0)
    (dotimes (i (* w h))
      (pset! (tref t 0) i (pref (tref fs 8) i)))
    (extrapolate t)
    (addBuoyancy fs timestep)
    (setBoundaryCondition fs)
    (buildRhs fs)
    (computeDensities fs)
    (buildPressureMatrix fs timestep)
    (buildPreconditioner fs)
    (project fs 2000)
    (applyPressure fs timestep)

    (extrapolate u)
    (extrapolate d)
    (extrapolate v)
    (setBoundaryCondition fs)

    (advect d timestep u v bodies)
    (advect t timestep u v bodies)
    (advect u timestep u v bodies)
    (advect v timestep u v bodies)
    ;; Make effect of advection visible, since it's not an in-place operation
    (flip d)
    (flip t)
    (flip u)
    (flip v)
    )))

(bind-func addInFlow
  "Set density and x/y velocity in given rectangle to d/u/v, respectively"
  (lambda (fs:FluidSolver* x y w h d t u v)
    (addInFlow:[void,FluidQuantity*,double,double,double,double,double]*
     (tref fs 0) x y (+ x w) (+ y h) d)
    (addInFlow:[void,FluidQuantity*,double,double,double,double,double]*
     (tref fs 16) x y (+ x w) (+ y h) t)
    (addInFlow:[void,FluidQuantity*,double,double,double,double,double]*
     (tref fs 1) x y (+ x w) (+ y h) u)
    (addInFlow:[void,FluidQuantity*,double,double,double,double,double]*
     (tref fs 2) x y (+ x w) (+ y h) v)
     ))

(bind-func maxTimestep
  "Returns the maximum allowed timestep. Note that the actual timestep
taken should usually be much below this to ensure accurate
simulation - just never above."
  (lambda (fs:FluidSolver*)
    (let ((maxVelocity 0.)
          (x 0) (y 0)
          (u 0.) (v 0.))
      (dotimes (y (tref fs 4))
        (dotimes (x (tref fs 3))
          (set! u (lerp (tref fs 1) (+ (convert x) .5) (+ (convert y) .5)))
          (set! u (lerp (tref fs 2) (+ (convert x) .5) (+ (convert y) .5)))
          (set! maxVelocity (max maxVelocity (sqrt (+ (* u u) (* v v)))))))
      ;; Fluid should not flow more than two grid cells per iteration,
      ;; so we clamp to sensible maximum value in case of very small
      ;; velocities
      (min (/ (* 2. (tref fs 5)) maxVelocity) 1.0))))
