;;; fluids-3.xtm --

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;;

;;; Code:

(sys:load "libs/core/adt.xtm")

(bind-val CELL_SOLID i32 2)
(bind-val CELL_FLUID i32 1)
(bind-val CELL_EMPTY i32 0)

(bind-val SOLID_BOX i64 1)
(bind-val SOLID_SPHERE i64 2)


(bind-func sgn
  (lambda (n:double)
    (convert
     (cond ((< n 0) -1)
           ((> n 0) 1)
           (else 0))
             i32)))

(bind-func nsgn
  (lambda (n:double)
    (convert (if (> n 0) 1 -1) i32)))

(bind-func length
  (lambda (x:double y:double)
    (sqrt (+ (* x x) (* y y)))))

(bind-func cubicPulse
  (lambda (x:double)
    (set! x (min (fabs x) 1.))
    (- 1. (* x x (- 3. (* 2. x))))))

(bind-func rotate
    (lambda (x:double* y:double* phi:double)
      (let ((tmpX (pref x 0)) (tmpY (pref y 0)))
        (pset! x 0 (+ (* (cos phi) tmpX) (* (sin phi) tmpY)))
        (pset! y 0 (+ (* (sin phi) tmpX -1.) (* (cos phi) tmpY)))
        )))

(bind-func triangleOccupancy
  (lambda (out1:double in:double out2:double)
    (/ (* 0.5 in in) (* (- out1 in) (- out2 in)))))

(bind-func trapezoidOccupancy
  (lambda (out1:double out2:double in1:double in2:double)
    (* 0.5 (- (/ (* -1. in1) (- out1 in1)) (/ in2 (- out2 in2))))))

(bind-func occupancy
  (lambda (d11:double d12:double d21:double d22:double)
    (let ((ds:|4,double|* (alloc)) (b:i32 0) (i 3))
      (afill! ds d11 d12 d22 d21)
      (while (>= i 0)
        (set! b (bitwise-or
                 (bitwise-shift-left b 1)
                 (convert (if (< (aref ds i) 0.) 1. 0.) i32)))
        (set! i (- i 1)))
      (cond
        ((= b #x0)
          0.)
        ((= b #x1)
          (triangleOccupancy d21 d11 d12))
        ((= b #x2)
          (triangleOccupancy d11 d12 d22))
        ((= b #x4)
          (triangleOccupancy d12 d22 d21))
        ((= b #x8)
          (triangleOccupancy d22 d21 d11))

        ((= b #xE)
          (- 1. (triangleOccupancy (* -1. d21) (* -1. d11) (* -1. d12))))
        ((= b #xD)
          (- 1. (triangleOccupancy (* -1. d11) (* -1. d12) (* -1. d22))))
        ((= b #xB)
          (- 1. (triangleOccupancy (* -1. d12) (* -1. d22) (* -1. d21))))
        ((= b #x7)
          (- 1. (triangleOccupancy (* -1. d22) (* -1. d21) (* -1. d11))))

        ((= b #x3)
          (trapezoidOccupancy d21 d22 d11 d12))
        ((= b #x6)
          (trapezoidOccupancy d11 d21 d12 d22))
        ((= b #x9)
          (trapezoidOccupancy d12 d22 d11 d21))
        ((= b #xC)
          (trapezoidOccupancy d11 d12 d21 d22))

        ((= b #x5)
          (+ (triangleOccupancy d11 d12 d22)
            (triangleOccupancy d22 d21 d11)))
        ((= b #xA)
          (+ (triangleOccupancy d21 d11 d12)
            (triangleOccupancy d12 d22 d21)))
        ((= b #xF)
          1.))
    )))



(bind-type SolidBody <double,double,double,double,double,double,double,double,i64>
    (constructor? . #f)
    "0 - x Position
    1 - y Position
    2 - x Scale
    3 - y Scale
    4 - theta rotation
    5 - x Velocity
    6 - y Velocity
    7 - Angular Velocity
    8 - Shape ")

(bind-func SolidBox
  (lambda (x:double y:double sx:double sy:double t:double vx:double vy:double vt:double)
    (let ((sb:SolidBody* (alloc)))
      (tfill! sb x y sx sy t vx vy vt SOLID_BOX)
      sb)))

(bind-func SolidSphere
  (lambda (x:double y:double s:double t:double vx:double vy:double vt:double)
    (let ((sb:SolidBody* (alloc)))
      (tfill! sb x y s s t vx vy vt SOLID_SPHERE)
      sb)))

(bind-func globalToLocal
  (lambda (sb:SolidBody* x:double* y:double*)
    (pset! x 0 (- (pref x 0) (tref sb 0)))
    (pset! y 0 (- (pref y 0) (tref sb 1)))
    (rotate x y (* -1. (tref sb 4)))
    (pset! x 0 (/ (tref sb 2) (pref x 0)))
    (pset! y 0 (/ (tref sb 3) (pref y 0)))
    ))

(bind-func localToGlobal
  (lambda (sb:SolidBody* x:double* y:double*)
    (pset! x 0 (* (tref sb 2) (pref x 0)))
    (pset! y 0 (* (tref sb 3) (pref y 0)))
    (rotate x y (tref sb 4))
    (pset! x 0 (+ (pref x 0) (tref sb 0)))
    (pset! y 0 (+ (pref y 0) (tref sb 1)))
    ))

(bind-func velocityX
  (lambda (sb:SolidBody* x:double y:double)
    (+ (* (- (tref sb 1) y) (tref sb 7)) (tref sb 5))))

(bind-func velocityY
  (lambda (sb:SolidBody* x:double y:double)
    (+ (* (- x (tref sb 0)) (tref sb 7)) (tref sb 6))))

(bind-func velocity
  (lambda (sb:SolidBody* vx:double* vy:double* x:double y:double)
    (pset! vx 0 (velocityX sb x y))
    (pset! vy 0 (velocityY sb x y))))

(bind-func update
  (lambda (sb:SolidBody* timestep)
    (tset! sb 0 (+ (* (tref sb 5) timestep) (tref sb 0)))
    (tset! sb 1 (+ (* (tref sb 6) timestep) (tref sb 1)))
    (tset! sb 4 (+ (* (tref sb 7) timestep) (tref sb 4)))
    ))

(bind-func distance
  (lambda (sb:SolidBody* x:double y:double)
    (cond
      ((= (tref sb 8) SOLID_BOX)
        (set! x (- x (tref sb 0)))
        (set! y (- y (tref sb 1)))
        (let ((xp:double* (alloc)) (yp:double* (alloc)))
        (pset! xp 0 x)
        (pset! yp 0 y)
        (rotate xp yp (* -1. (tref sb 4)))
        (set! x (pref xp 0))
        (set! y (pref yp 0))
        (let ((dx (- (fabs x) (* (tref sb 2) 0.5)))
              (dy (- (fabs y) (* (tref sb 3) 0.5))))
            (if (or (>= dx 0.) (>= dy 0.))
              (length (max dx 0.0) (max dy 0.0))
              (max dx dy)))))
      ((= (tref sb 8) SOLID_SPHERE)
        (- (length (- x (tref sb 0)) (- y (tref sb 1))) (* 0.5 (tref sb 2)))))))

(bind-func closestSurfacePoint
  (lambda (sb:SolidBody* x:double* y:double*)
    (cond
      ((= (tref sb 8) SOLID_BOX)
        (pset! x 0 (- (pref x 0) (tref sb 0)))
        (pset! y 0 (- (pref y 0) (tref sb 1)))
        (rotate x y (* -1. (tref sb 4)))
        (let ((dx (- (fabs (pref x 0)) (* (tref sb 2) 0.5)))
              (dy (- (fabs (pref y 0)) (* (tref sb 3) 0.5))))
            (if (> dx dy)
              (pset! x 0 (* (convert (nsgn (pref x 0))) 0.5 (tref sb 2)))
              (pset! y 0 (* (convert (nsgn (pref y 0))) 0.5 (tref sb 3))))
            (rotate x y (tref sb 4))
            (pset! x 0 (+ (pref x 0) (tref sb 0))))
            (pset! y 0 (+ (pref y 0) (tref sb 1))))
        ((= (tref sb 8) SOLID_SPHERE)
          (globalToLocal sb x y)
          (let ((r (length (pref x 0) (pref y 0))))
          (if (< r  1e-4)
            (begin
              (pset! x 0 0.5)
              (pset! y 0 0.))
            (begin
              (pset! x 0 (/ (pref x 0) (* 2.0 r)))
              (pset! y 0 (/ (pref y 0) (* 2.0 r)))))
          (localToGlobal sb x y))))
          void))

(bind-func distanceNormal
  (lambda (sb:SolidBody* nx:double* ny:double* x:double y:double)
    (let ((xp:double* (alloc)) (yp:double* (alloc)))
      (pset! xp 0 x)
      (pset! yp 0 y)
      (cond
        ((= (tref sb 8) SOLID_BOX)
          (pset! xp 0 (- (pref xp 0) (tref sb 0)))
          (pset! yp 0 (- (pref yp 0) (tref sb 1)))
            (rotate xp yp (* -1. (tref sb 4)))
            (set! x (pref xp 0))
            (set! y (pref yp 0))
            (if (> (- (fabs x) (* 0.5 (tref sb 2))) (- (fabs y) (* 0.5 (tref sb 3))))
              (begin
                (pset! nx 0 (convert (nsgn x)))
                (pset! ny 0 0.))
              (begin
                (pset! ny 0 (convert (nsgn y)))
                (pset! nx 0 0.)))
            (rotate nx ny (tref sb 4)))
          ((= (tref sb 8) SOLID_SPHERE)
            (set! x (- x (tref sb 0)))
            (set! y (- y (tref sb 1)))
            (let ((r:double (length x y)))
              (if (< r 1e-4)
                (begin
                  (pset! nx 0 1.)
                  (pset! ny 0 0.))
                (begin
                  (pset! nx 0 (/ x r))
                  (pset! ny 0 (/ y r)))))))
                  void)))


(bind-type FluidQuantity <double*,double*,i32,i32,double,double,double,double*,double*,i32*,i32*,i32*,double*,double*>
  (constructor? . #f)
  "0 - fluid data
  1  - old-quantities
  2  - grid width
  3  - grid height
  4  - x offset
  5 - y offset
  6 - grid cell height
  7  - x normal
  8  - y normal
  9  - cell type
  10  - index of closest body
  11 - mask auxiliary array
  12 - phi
  13 - volume")

(bind-func matrixb
  (lambda (fq:FluidQuantity* matix:double*)
    (let ((i:i32 0) (w (tref fq 2)) (h (tref fq 3)) (a:i32 0))
      (dotimes (i (* w h))
        (let ((k (pref matix i)))
          (if (> (fabs k) 0.5)
            (begin
            (printf "%d:  %f " i k)
            (set! a (+ 1 a))
            (if (= a 5)
            (begin
            (println)
            (set! a 0)))))))
        (printf "\n************************\n"))))

(bind-func FluidQuantity
  (lambda (w h ox oy hx)
    (let ((fq:FluidQuantity* (alloc))
          (src:double* (alloc (* w h)))
          (old:double* (alloc (* w h)))
          (xNormal:double* (alloc (* w h)))
          (yNormal:double* (alloc (* w h)))
          (cell:i32* (alloc (* w h)))
          (body:i32* (alloc (* w h)))
          (mask:i32* (alloc (* w h)))
          (phi:double* (alloc (* (+ w 1) (+ h 1))))
          (volume:double* (alloc (* w h)))
          (i:i32 0))
          (dotimes (i (* w h))
            (pset! cell i CELL_FLUID)
            (pset! volume i 1.))
      (tfill! fq src old w h ox oy hx xNormal yNormal cell body mask phi volume)
      fq)))

(bind-func FluidQuantity_h
  (lambda (w h ox oy hx)
    (let ((fq:FluidQuantity* (halloc))
          (src:double* (halloc (* w h)))
          (old:double* (halloc (* w h)))
          (xNormal:double* (alloc (* w h)))
          (yNormal:double* (alloc (* w h)))
          (cell:i32* (halloc (* w h)))
          (body:i32* (halloc (* w h)))
          (mask:i32* (halloc (* w h)))
          (phi:double* (halloc (* (+ w 1) (+ h 1))))
          (volume:double* (halloc (* w h)))
          (i:i32 0))
          (dotimes (i (* w h))
            (pset! cell i CELL_FLUID)
            (pset! volume i 1.))
      (tfill! fq src old w h ox oy hx xNormal yNormal cell body mask phi volume)
      fq)))

(bind-func FluidQuantity_free
  "free a halloc'ed FluidQuantity created with FluidQuantity_h"
  (lambda (fq:FluidQuantity*)
    (free (tref fq 0))
    (free (tref fq 1))
    (free fq)))

(bind-func sum
  (lambda (fq:FluidQuantity*)
    (let ((running_sum 0.)
          (i 0))
      (dotimes (i (convert (* (tref fq 2) (tref fq 3))))
        (set! running_sum (+ running_sum (pref (tref fq 0) i))))
      running_sum)))

(bind-func lerp
  (lambda (a:double b:double x:double)
    (+ (* a (- 1. x)) (* b x))))

(bind-func addSample
  (lambda (fq:FluidQuantity* weight:double* value x:double y:double ix iy)
    (if (not (or (< ix 0) (< iy 0) (>= ix (tref fq 2)) (>= iy (tref fq 3))))
      (begin
        (let ((k (* (- 1.0 (fabs (- (convert ix) x))) (- 1.0 (fabs (- (convert iy) y))))))
          (pset! weight (+ ix (* iy (tref fq 2))) (+ (pref weight (+ ix (* iy (tref fq 2)))) k))
          (pset! (tref fq 0) (+ ix (* iy (tref fq 2))) (+ (pref (tref fq 0) (+ ix (* iy (tref fq 2))))
                                                         (* k value)))
        )))
        void))

(bind-func cerp
  (lambda (a b c d x)
    (let ((xsq (* x x)) (xcu (* x xsq))
          (minV (min a (min b (min c (min d x)))))
          (maxV (max a (max b (max c (max d x)))))
          (t
            (+ (* a (- (+ 0.0 (* 1.0 xsq)) (+ (* 0.5 x) (* 0.5 xcu))))
               (* b (- (+ 1.0 (* 0.0 x) (* 1.5 xcu)) (* 2.5 xsq)))
               (* c (- (+ 0.0 (* 0.5 x) (* 2.0 xsq)) (* 1.5 xcu)))
               (* d (- (+ 0.0 (* 0.0 x) (* 0.5 xcu)) (* 0.5 xsq))))))
               (min (max t minV) maxV))))

(bind-func at
  (lambda (fq:FluidQuantity* x y)
    (pref (tref fq 0) (+ (* y (tref fq 2)) x))))

(bind-func at
  (lambda (fq:FluidQuantity* x y)
    (pref-ptr (tref fq 0) (+ (* y (tref fq 2)) x))))

(bind-func copy
  (lambda (fq:FluidQuantity*)
    (let ((w (tref fq 2)) (h (tref fq 3)) (i:i32 0)
          (src (tref fq 0)) (old (tref fq 1)))
      (dotimes (i (* w h))
        (pset! old i (pref src i))))))

(bind-func diff
  (lambda (fq:FluidQuantity* alpha)
    (let ((i:i32 0) (w (tref fq 2)) (h (tref fq 3)) (src (tref fq 0)) (old (tref fq 1)))
          (dotimes (i (* w h))
            (pset! src i (- (pref src i) (* (- 1.0 alpha) (pref old i))))))))

(bind-func undiff
  (lambda (fq:FluidQuantity* alpha)
    (let ((i:i32 0) (w (tref fq 2)) (h (tref fq 3)) (src (tref fq 0)) (old (tref fq 1)))
      (dotimes (i (* w h))
        (pset! src i (+ (pref src i) (* (- 1.0 alpha) (pref old i))))))))

(bind-func volume
  (lambda (fq:FluidQuantity* x:i32 y:i32)
    (pref (tref fq 13) (+ x (* y (tref fq 2))))))

(bind-func cerp
  "Cubic intERPolate on grid at coordinates (x, y).
   Coordinates will be clamped to lie in simulation domain"
  (lambda (fq:FluidQuantity* x:double y:double)
    (let ((ox (tref fq 4)) (oy (tref fq 5)) (w:i32 (tref fq 2)) (h:i32 (tref fq 3)))
      (set! x (min (max (- x ox) 0.) (- (convert w) 1.001)))
      (set! y (min (max (- y oy) 0.) (- (convert h) 1.001)))
      (let ((ix (convert x i32))
            (iy (convert y i32)))
        (set! x (- x (convert ix)))
        (set! y (- y (convert iy)))
        (let ((x0 (max (- ix 1) 0)) (x1 ix) (x2 (+ ix 1)) (x3 (min (+ ix 2) (- w 1)))
              (y0 (max (- iy 1) 0)) (y1 iy) (y2 (+ iy 1)) (y3 (min (+ iy 2) (- h 1))))
          (let ((q0 (cerp:[double,double,double,double,double,double]*
                     (at:[double,FluidQuantity*,i32,i32]* fq x0 y0)
                     (at:[double,FluidQuantity*,i32,i32]* fq x1 y0)
                     (at:[double,FluidQuantity*,i32,i32]* fq x2 y0)
                     (at:[double,FluidQuantity*,i32,i32]* fq x3 y0) x))
                (q1 (cerp:[double,double,double,double,double,double]*
                     (at:[double,FluidQuantity*,i32,i32]* fq x0 y1)
                     (at:[double,FluidQuantity*,i32,i32]* fq x1 y1)
                     (at:[double,FluidQuantity*,i32,i32]* fq x2 y1)
                     (at:[double,FluidQuantity*,i32,i32]* fq x3 y1) x))
                (q2 (cerp:[double,double,double,double,double,double]*
                     (at:[double,FluidQuantity*,i32,i32]* fq x0 y2)
                     (at:[double,FluidQuantity*,i32,i32]* fq x1 y2)
                     (at:[double,FluidQuantity*,i32,i32]* fq x2 y2)
                     (at:[double,FluidQuantity*,i32,i32]* fq x3 y2) x))
                (q3 (cerp:[double,double,double,double,double,double]*
                     (at:[double,FluidQuantity*,i32,i32]* fq x0 y3)
                     (at:[double,FluidQuantity*,i32,i32]* fq x1 y3)
                     (at:[double,FluidQuantity*,i32,i32]* fq x2 y3)
                     (at:[double,FluidQuantity*,i32,i32]* fq x3 y3) x)))
            (let ((k (cerp:[double,double,double,double,double,double]* q0 q1 q2 q3 y)))
              (cerp:[double,double,double,double,double,double]* q0 q1 q2 q3 y))))))))

(bind-func lerp
  "Linear intERPolate on grid at coordinates (x, y).
  Coordinates will be clamped to lie in simulation domain"
  (lambda (fq:FluidQuantity* x:double y:double)
    (let ((ox (tref fq 4)) (oy (tref fq 5)) (w:i32 (tref fq 2)) (h:i32 (tref fq 3)))
    (set! x (min (max (- x ox) 0.) (- (convert w) 1.001)))
    (set! y (min (max (- y oy) 0.) (- (convert h) 1.001)))
    (let ((ix (convert x i32))
          (iy (convert y i32)))
      (set! x (- x (convert ix)))
      (set! y (- y (convert iy)))
      (let ((x00 (at:[double,FluidQuantity*,i32,i32]* fq (+ ix 0) (+ iy 0)))
            (x01 (at:[double,FluidQuantity*,i32,i32]* fq (+ ix 0) (+ iy 1)))
            (x10 (at:[double,FluidQuantity*,i32,i32]* fq (+ ix 1) (+ iy 0)))
            (x11 (at:[double,FluidQuantity*,i32,i32]* fq (+ ix 1) (+ iy 1))))
         (lerp:[double,double,double,double]*
         (lerp:[double,double,double,double]* x00 x10 x)
         (lerp:[double,double,double,double]* x01 x11 x)
         y))))))

(bind-func rungeKutta3
  (lambda (fq:FluidQuantity* xp:double* yp:double* timestep u:FluidQuantity* v:FluidQuantity*)
    (let ((hx (tref fq 6)) (x (pref xp 0)) (y (pref yp 0))
      (firstU (/ (lerp u x y) hx))
      (firstV (/ (lerp v x y) hx))
        (midX (- x (* 0.5 timestep firstU)))
        (midY (- y (* 0.5 timestep firstV)))
        (midU (/ (lerp u midX midY) hx))
        (midV (/ (lerp v midX midY) hx))
            (lastX (- x (* 0.75 timestep midU)))
            (lastY (- y (* 0.75 timestep midV)))
            (lastU (lerp u lastX lastY))
            (lastV (lerp v lastX lastY)))
                  (pset! xp 0 (- x (* timestep (+ (* (/ 2. 9.) firstU) (* (/ 3. 9.) midU) (* (/ 4. 9.) lastU)))))
                  (pset! yp 0 (- y (* timestep (+ (* (/ 2. 9.) firstV) (* (/ 3. 9.) midV) (* (/ 4. 9.) lastV)))))
                  void)))

(bind-func euler
  (lambda (fq:FluidQuantity* x:double* y:double* timestep u:FluidQuantity* v:FluidQuantity*)
    (let ((uVel (/ (lerp u (pref x 0) (pref y 0)) (tref fq 6)))
          (vVel (/ (lerp v (pref x 0) (pref y 0)) (tref fq 6))))
      (pset! x 0 (- (pref x 0) (* uVel timestep)))
      (pset! y 0 (- (pref y 0) (* vVel timestep))))
    void))

(bind-func flip
  (lambda (fq:FluidQuantity*)
    (let ((tmp:double* null))
      (set! tmp (tref fq 0))
      (tset! fq 0 (tref fq 1))
      (tset! fq 1 tmp))))

(bind-func src
  (lambda (fq:FluidQuantity*)
    (tref fq 0)))

(bind-func backProject
  (lambda (fq:FluidQuantity* x:double* y:double* bodies:List{SolidBody*}*)
    (let ((rx (min (max (convert (- (pref x 0) (tref fq 4)) i32) (convert 0 i32)) (convert (- (tref fq 2) 1) i32)))
          (ry (min (max (convert (- (pref y 0) (tref fq 5)) i32) (convert 0 i32)) (convert (- (tref fq 3) 1) i32)))
          (cell (tref fq 9)) (w (tref fq 2)) (body (tref fq 10)) (idx (+ rx (* ry w))))
      (if (<> (pref cell idx) CELL_FLUID)
        (begin
          (pset! x 0 (* (- (pref x 0) (tref fq 4)) (tref fq 6)))
          (pset! y 0 (* (- (pref y 0) (tref fq 5)) (tref fq 6)))
          (closestSurfacePoint (nth bodies 0) x y)
          (pset! x 0 (+ (/ (pref x 0) (tref fq 6)) (tref fq 4)))
          (pset! y 0 (+ (/ (pref y 0) (tref fq 6)) (tref fq 5 )))))
        void)))

(bind-func advect
  "Advect grid in velocity field u, v with given timestep"
  (lambda (fq timestep u v bodies)
    (let ((ix:i32 0) (idx 0)
          (iy:i32 0) (idy 0)
          (x:double* (alloc))
          (y:double* (alloc))
          (cell (tref fq 9)))
      (dotimes (iy (tref fq 3))
        (dotimes (ix (tref fq 2))
          (if (= (pref cell idx) CELL_FLUID)
          (begin
          (pset! x 0 (+ (convert ix) (tref fq 4)))
          (pset! y 0 (+ (convert iy) (tref fq 5)))
          ;; First component: Integrate in time
          (rungeKutta3 fq x y timestep u v)
          ;; Second component: Interpolate from grid
          (backProject fq x y bodies)
          (pset! (tref fq 1) idx (cerp:[double,FluidQuantity*,double,double]* fq (pref x 0) (pref y 0)))))
          (set! idx (+ idx 1))))
    void)))

(bind-func fillSolidFields
  (lambda (fq:FluidQuantity* bodies)
    (if (not (null? bodies))
        (begin
        (let ((iy:i32 0) (idx:i32 0) (ix:i32 0) (body (tref fq 10)) (cell (tref fq 9)) (phi (tref fq 12))
              (normalX (tref fq 7)) (normalY (tref fq 8)) (x 0.) (y 0.) (w (tref fq 2)) (h (tref fq 3)) (volume (tref fq 13)))

          (dotimes (iy (+ h 1))
            (dotimes (ix (+ w 1))
              (set! x (* (- (+ (convert ix) (tref fq 4)) 0.5) (tref fq 6)))
              (set! y (* (- (+ (convert iy) (tref fq 5)) 0.5) (tref fq 6)))
              (pset! phi idx (distance (car bodies) x y))
              (let ((remaining_bodies (cdr bodies)))
                (while (not (null? remaining_bodies))
                  (pset! phi idx (min (pref phi idx) (distance (car remaining_bodies) x y)))
                  (set! remaining_bodies (cdr remaining_bodies))))
              (set! idx (+ 1 idx))))

          (set! iy 0)
          (set! ix 0)
          (set! idx 0)

          (dotimes (iy h)
            (dotimes (ix w)
              (set! x (* (+ (convert ix double) (tref fq 4)) (tref fq 6)))
              (set! y (* (+ (convert iy double) (tref fq 5)) (tref fq 6)))
              (pset! body idx 0)

              (let ((d (distance (car bodies) x y)) ;; distance to "head" of bodies list
                    (remaining_bodies (cdr bodies)) ;; pointer to "rest" of bodies list
                    (i:i32 1)
                    (id 0.))
                (while (not (null? remaining_bodies))
                  (set! id (distance (car remaining_bodies) x y))
                  (if (< id d)
                      (begin
                        (pset! body idx (convert i i32))
                        (set! d id)))
                  ;; "recurse" down the list
                  (set! i (+ i 1))
                  (set! remaining_bodies (cdr remaining_bodies))))


                (let ((idxp (+ ix (* iy (+ w 1)))))
                  (pset! volume idx (- 1. (occupancy
                                            (pref phi idxp) (pref phi (+ idxp 1))
                                            (pref phi (+ idxp w 1)) (pref phi (+ idxp w 2))))))
                (if (< (pref volume idx) 0.01)
                  (pset! volume idx 0.))

          (let ((normxp:double* (alloc)) (normyp:double* (alloc)))
            (pset! normxp 0 (pref normalX idx))
            (pset! normyp 0 (pref normalY idx))
            (distanceNormal (nth bodies (convert (pref body idx))) normxp normyp x y)
            (pset! normalX idx (pref normxp 0))
            (pset! normalY idx (pref normyp 0)))

            (if (= (pref volume idx) 0.)
              (pset! cell idx CELL_SOLID)
              (pset! cell idx CELL_FLUID))

            (set! idx (+ 1 idx)))))))
        void))

(bind-func addInFlow
  "Sets fluid quantity inside the given rect to value `v'"
  (lambda (fq:FluidQuantity* x0 y0 x1 y1 v)
    (let ((hx (tref fq 6))
          (ix0 (convert (- (/ x0 hx) (tref fq 4)) i32))
          (iy0 (convert (- (/ y0 hx) (tref fq 5)) i32))
          (ix1 (convert (- (/ x1 hx) (tref fq 4)) i32))
          (iy1 (convert (- (/ y1 hx) (tref fq 5)) i32))
          (y (max iy0 0)))
      ;; Sets fluid quantity inside the given rect to value `v'
      (while (< y (min iy1 (convert (tref fq 3))))
      (let ((x (max ix0 0)))
        (while (< x (min ix1 (convert (tref fq 3))))
          (let ((l (length (/ (- (* 2. (+ (convert x) .5) hx) (+ x0 x1)) (- x1 x0))
                           (/ (- (* 2. (+ (convert y) .5) hx) (+ y0 y1)) (- y1 y0))))
                (vi (* v (cubicPulse l))))
          (if (< (fabs (pref (tref fq 0) (+ x (* y (tref fq 2)))))
                 (fabs vi))
                 (begin
              (pset! (tref fq 0)
                     (+ x (* y (tref fq 2)))
                     vi))))
          (set! x (+ x 1)))
        (set! y (+ y 1))))
      void)))

(bind-func fillSolidMask
  (lambda (fq:FluidQuantity*)
    (let ((y 0) (x 0) (h (tref fq 3)) (w (tref fq 2)) (mask (tref fq 11)) (cell (tref fq 9))
      (normalX (tref fq 7)) (normalY (tref fq 8)))
        (dotimes (x w)
          (pset! mask x #xFFFFFFFF)
          (pset! mask (+ x (* (- h 1) w)) #xFFFFFFFF))

        (dotimes (y h)
          (pset! mask (* y w) #xFFFFFFFF)
          (pset! mask (+ (* y w) (- w 1)) #xFFFFFFFF))

        (set! y 1)
        (while (< y (- h 1))
          (set! x 1)
          (while (< x (- w 1))
            (let ((idx (+ x (* y w))))
              (if (= (pref (tref fq 9) idx) CELL_SOLID)
                (begin
                (let ((nx (pref normalX idx))
                      (ny (pref normalY idx)))
                    (pset! mask idx 0)
                    (if (and (<> nx 0.)
                             (<> (pref cell (+ idx (sgn nx))) CELL_FLUID))
                      (pset! mask idx (bitwise-or (pref mask idx) 1)))
                    (if (and (<> ny 0.)
                             (<> (pref cell (+ idx (* (convert w) (sgn ny)))) CELL_FLUID))
                      (pset! mask idx (bitwise-or (pref mask idx) 2)))))
                  (begin
                    (if (= (pref cell idx) CELL_EMPTY)
                      (begin
                        (pset! mask idx (convert
                          (and (<> (pref cell (- idx 1)) CELL_FLUID)
                               (<> (pref cell (+ idx 1)) CELL_FLUID)
                               (<> (pref cell (- idx w)) CELL_FLUID)
                               (<> (pref cell (+ idx w)) CELL_FLUID)))))))))
                      (set! x (+ 1 x)))
                      (set! y (+ 1 y))))))

(bind-func extrapolateNormal
  (lambda (fq:FluidQuantity* idx)
    (let ((normalX (tref fq 7)) (normalY (tref fq 8))
          (nx (pref normalX idx)) (ny (pref normalY idx))
          (src (tref fq 0))
          (srcX (pref src (+ idx (sgn nx))))
          (srcY (pref src (+ idx (* (tref fq 2) (sgn ny))))))
      (/ (+ (* (fabs nx) srcX) (* (fabs ny) srcY)) (+ (fabs nx) (fabs ny))))))

(bind-func extrapolateAverage
  (lambda (fq:FluidQuantity* idx)
    (let ((value 0.0) (count 0) (cell (tref fq 9)) (src (tref fq 0)) (w (tref fq 2)))
      (if (= (pref cell (- idx 1)) CELL_FLUID)
        (begin
          (set! value (+ value (pref src (- idx 1))))
         (set! count (+ count 1))))
      (if (= (pref cell (+ idx 1)) CELL_FLUID)
        (begin
          (set! value (+ value (pref src (+ idx 1))))
         (set! count (+ count 1))))
      (if (= (pref cell (- idx w)) CELL_FLUID)
        (begin
          (set! value (+ value (pref src (- idx w))))
         (set! count (+ count 1))))
      (if (= (pref cell (+ idx w)) CELL_FLUID)
        (begin
          (set! value (+ value (pref src (+ idx w))))
         (set! count (+ count 1))))
    (/ value (convert count)))))



(bind-func freeSolidNeighbour
  (lambda (fq:FluidQuantity* idx:i32 border mask)
    (let ((fqmask:i32* (tref fq 11)) (cell (tref fq 9)))
      (pset! fqmask idx (bitwise-and (pref fqmask idx) (~ mask)))
      (if (and (= (pref cell idx) CELL_SOLID) (= (pref fqmask idx) 0))
            (set! border (cons idx border)))
          border)))

(bind-func freeEmptyNeighbour
  (lambda (fq:FluidQuantity* idx:i32 border)
    (let ((fqmask:i32* (tref fq 11)) (cell (tref fq 9)))
      (if (and (= (pref cell idx) CELL_EMPTY) (= (pref fqmask idx) 1))
            (begin
              (pset! fqmask idx 1)
              (set! border (cons idx border))))
          border)))

(bind-func extrapolateEmptyBorders
  (lambda (fq:FluidQuantity*)
    (let ((x 1) (y 1) (w (tref fq 2)) (h (tref fq 3))
          (cell (tref fq 9)) (src (tref fq 0)) (i:i32 0)
          (idxT 0) (idxB 0) (idxL 0) (idxR 0)
          (idxTL 0) (idxTR (- w 1)) (idxBL (* (- h 1) w)) (idxBR (- (* h w) 1)))
      (while (< x (- w 1))
        (set! idxT x)
        (set! idxB (+ x (* w (- h 1))))
        (if (= (pref cell idxT) CELL_EMPTY)
          (pset! src idxT (pref src (+ idxT w))))
        (if (= (pref cell idxB) CELL_EMPTY)
          (pset! src idxB (pref src (- idxB w))))
        (set! x (+ 1 x)))
      (while (< y (- h 1))
        (set! idxL (* y w))
        (set! idxR (+ (* y w) (- w 1)))
        (if (= (pref cell idxL) CELL_EMPTY)
          (pset! src idxL (pref src (+ idxL 1))))
        (if (= (pref cell idxR) CELL_EMPTY)
          (pset! src idxR (pref src (- idxR 1))))
        (set! y (+ 1 y)))

        (if (= (pref cell idxTL) CELL_EMPTY)
          (pset! src idxTL (* 0.5 (+ (pref src (+ idxTL 1)) (pref src (+ idxTL w))))))
        (if (= (pref cell idxTR) CELL_EMPTY)
          (pset! src idxTR (* 0.5 (+ (pref src (- idxTR 1)) (pref src (+ idxTR w))))))
        (if (= (pref cell idxBL) CELL_EMPTY)
          (pset! src idxBL (* 0.5 (+ (pref src (+ idxBL 1)) (pref src (- idxBL w))))))
        (if (= (pref cell idxBR) CELL_EMPTY)
          (pset! src idxBR (* 0.5 (+ (pref src (- idxBR 1)) (pref src (- idxBR w))))))

        (dotimes (i (* w h))
          (if (= (pref cell i) CELL_EMPTY)
            (pset! cell i CELL_FLUID)))
        )))

(bind-func extrapolate
  (lambda (fq:FluidQuantity*)
    (fillSolidMask fq)
    (let ((border (list)) (y:i32 1) (x:i32 1) (idx:i32 0)
          (w:i32 (tref fq 2)) (h:i32 (tref fq 3)) (src (tref fq 0))
          (normalX (tref fq 7)) (normalY (tref fq 8)))
      (while (< y (- h 1))
        (set! x 1)
        (while (< x (- w 1))
          (set! idx (+ x (* w y)))
          (if (and (<> (pref (tref fq 9) idx) CELL_FLUID)
                   (= (pref (tref fq 11) idx) 0))
              (begin
              (set! border (cons idx border))))
          (set! x (+ 1 x)))
        (set! y (+ 1 y)))
        (while (not (null? border))
          (set! idx (car border))
          (set! border (cdr border))

          (if (= (pref (tref fq 9) idx) CELL_EMPTY)
            (begin
              (pset! (tref fq 9) idx CELL_FLUID)
              (pset! src idx (extrapolateAverage fq idx)))
            (pset! src idx (extrapolateNormal fq idx)))
          (pset! src idx (extrapolateNormal fq idx))
           (if (> (pref normalX (- idx 1)) 0.)
            (begin
            (set! border (freeSolidNeighbour fq (- idx 1) border (convert 2 i32)))))
           (if (< (pref normalX (+ idx 1)) 0.)
            (begin
            (set! border (freeSolidNeighbour fq (+ idx 1) border (convert 2 i32)))))
           (if (> (pref normalY (- idx w)) 0.)
            (begin
            (set! border (freeSolidNeighbour fq (- idx w) border (convert 1 i32)))))
           (if (< (pref normalY (+ idx  w)) 0.)
            (begin
            (set! border (freeSolidNeighbour fq (+ idx w) border (convert 1 i32)))))
          (set! border (freeEmptyNeighbour fq (- idx 1) border))
          (set! border (freeEmptyNeighbour fq (+ idx 1) border))
          (set! border (freeEmptyNeighbour fq (- idx w) border))
          (set! border (freeEmptyNeighbour fq (+ idx w) border))
          )
          (extrapolateEmptyBorders fq))))

(bind-func fromParticles
  (lambda (fq:FluidQuantity* weight:double* count posX:double* posY:double* property:double*)
    (let ((src (tref fq 0)) (w (tref fq 2)) (h (tref fq 3)) (a:i32 0)
          (x 0.) (y 0.) (i:i32 0) (ix 0) (iy 0))
      (dotimes (a (* w h))
        (pset! src a 0.)
        (pset! weight a 0.))
      (dotimes (i count)
        (set! x (- (pref posX i) (tref fq 4)))
        (set! y (- (pref posY i) (tref fq 5)))
        (set! x (max 0.5 (min (- (convert w double) 1.5) x)))
        (set! y (max 0.5 (min (- (convert h double) 1.5) y)))
        (set! ix (convert x i32))
        (set! iy (convert y i32))

        (addSample fq weight (pref property i) x y (+ ix 0) (+ iy 0))
        (addSample fq weight (pref property i) x y (+ ix 1) (+ iy 0))
        (addSample fq weight (pref property i) x y (+ ix 0) (+ iy 1))
        (addSample fq weight (pref property i) x y (+ ix 1) (+ iy 1)))

        (set! i 0)
        (dotimes (i (* w h))
          (if (<> (pref weight i) 0.0)
            (begin
            (pset! src i (/ (pref src i) (pref weight i)))
            void)
            (if (= (pref (tref fq 9) i) CELL_FLUID)
              (begin
              (pset! (tref fq 9) i CELL_EMPTY)void)))))))

(bind-func getidx
  (lambda (fq:FluidQuantity* x:i32 y:i32)
    (+ (* (tref fq 2) y) x)))

(bind-type ParticleQuantities <i32,i32,i32,i32,i32,i32,i32,double,List{SolidBody*}*,double*,i32*,double*,double*,List{double*}*,List{FluidQuantity*}*>
  (constructor? . #f)
  "0 - maximum particles per cell
   1 - minimum particles per cell
   2 - initial particles per cell
   3 - number of particles currently active
   4 - maximum particles
   5 - width
   6 - height
   7 - grid cell height
   8 - Solid Bodies
   9 - filter weights auxiliary array
   10 - number of particles per cell
   11 - particle positions X
   12 - particle positions Y
   13 - particle properites
   14 - Fluid Quantities
   ")

(bind-func pointinBody
 (lambda (qs:ParticleQuantities* x y)
   (let ((bodies (tref qs 8)) (ret #f))
         (while (not (null? bodies))
           (if (< (distance (car bodies) (* x (tref qs 7)) (* y (tref qs 7))) 0.0)
             (set! ret #t))
             (set! bodies (cdr bodies)))
       ret)))

(bind-func initParticles
 (lambda (qs:ParticleQuantities*)
   (let ((idx 0) (x 0) (y 0) (avgpercell (tref qs 2)) (i 0)
         (w (tref qs 5)) (h (tref qs 6))
         (posX (tref qs 11)) (posY (tref qs 12)))
     (dotimes (y h)
       (dotimes (x w)
         (dotimes (i avgpercell)
           (pset! posX idx (+ (convert x) (random)))
           (pset! posY idx (+ (convert y) (random)))
           (if (pointinBody qs (pref posX idx) (pref posY idx))
             (set! idx (- idx 1)))
           (set! idx (+ idx 1)))))
       (tset! qs 3 idx))))

(bind-func ParticleQuantities
  (lambda (w h hx bodies)
    (let ((qs:ParticleQuantities* (alloc))
          (maxpercell 12)
          (minpercell 3)
          (avgpercell 4)
          (particlecount 0)
          (maxParticles (* w h maxpercell))
          (posX:double* (alloc maxParticles))
          (posY:double* (alloc maxParticles))
          (weight:double* (alloc (* (+ w 1) (+ h 1))))
          (counts:i32* (alloc (* w h)))
          (properties:List{double*}* null)
          (quantities:List{FluidQuantity*}* null))
      (tfill! qs maxpercell minpercell avgpercell particlecount maxParticles w h hx bodies weight counts posX posY properties quantities)
      (initParticles qs)
        qs)))

(bind-func countparticles
  (lambda (qs:ParticleQuantities*)
    (let ((w (tref qs 5)) (h (tref qs 6)) (a 0)
          (ix 0) (iy 0) (i 0))
      (dotimes (a (* w h))
        (pset! (tref qs 10) 0 0))
      (dotimes (i (tref qs 3))
        (set! ix (convert (pref (tref qs 11) i) i32))
        (set! iy (convert (pref (tref qs 12) i) i32))
        (if (and (>= ix 0) (>= iy 0) (< ix w) (< iy h))
          (pset! (tref qs 10) (+ ix (* iy w)) (+ (pref (tref qs 10) (+ ix (* iy w))) 1)))
        ))))

(bind-func pruneParticles
  (lambda (qs:ParticleQuantities*)
    (let ((i 0) (w (tref qs 5)) (h (tref qs 6))
          (ix 0) (iy 0) (idx 0) (j 0)
          (posX (tref qs 11)) (posY (tref qs 12))
          (quantities (tref qs 14)) (t 0))
      (while (< i (tref qs 3))
        (set! ix (convert (pref posX i) i32))
        (set! iy (convert (pref posY i) i32))
        (set! idx (+ ix (* iy w)))

        (if (not (or (< ix 0) (< iy 0) (>= ix w) (>= iy h)))
          (begin
            (if (> (pref (tref qs 10) idx) (tref qs 0))
              (begin
                (set! j (- (tref qs 3) 1))
                (tset! qs 3 (- (tref qs 3) 1))
                (pset! posX i (pref posX j))
                (pset! posY i (pref posY j))
                (set! t 0)
                (while (< t (length quantities))
                (let ((property:double* (nth (tref qs 13) t)))
                  (pset! (nth (tref qs 13) t) i (pref property j)))
                  (set! t (+ t 1)))
                (pset! (tref qs 10) idx (- (pref (tref qs 10) idx) 1))
                (set! i (- i 1))))))
                (set! i (+ i 1))))))

(bind-func seedParticles
  (lambda (qs:ParticleQuantities*)
    (let ((idx:i32 0) (x:i32 0) (y:i32 0) (minpercell (tref qs 1)) (i:i32 0)
          (w (tref qs 5)) (h (tref qs 6)) (j:i32 0) (t 0)
          (posX (tref qs 11)) (posY (tref qs 12))
          (quantities (tref qs 14)))
      (printf "Print 1\n")
      (dotimes (y h)
        (dotimes (x w)
          (printf "minpercell:%d\ncount[%d]:%d\n" minpercell idx (pref (tref qs 10) idx))
          (while (< i (- minpercell (pref (tref qs 10) idx)))
            (if (<> (tref qs 3) (tref qs 0))
            (begin
            (set! j (tref qs 3))
            (pset! posX j (+ (convert x double) (random)))
            (pset! posY j (+ (convert y double) (random)))
            (if (not (pointinBody qs (pref posX idx) (pref posY idx)))
              (begin
                (while (< t (length quantities))
                (printf "Print 2 - %d\n" (length quantities))
                  (pset! (nth (tref qs 13) t) j (lerp (nth quantities t) (pref posX j) (pref posY j)))
                  (set! t (+ t 1)))
              ;;  (printf "Print 3 - idx:%d\n" idx)
                (tset! qs 3 (+ (tref qs 3) 1))))))
                (set! i (+ i 1)))
          (set! idx (+ idx 1))))
          (printf "Print 4\n")
          void)))

(bind-func backProject
  (lambda (qs:ParticleQuantities* x:double* y:double*)
    (let ((d 1e30) (closestBody -1) (i 0)
          (bodies (tref qs 8)) (id 0.)
          (nx:double* (alloc)) (ny:double* (alloc)))
      (dotimes (i (length bodies))
       (set! id (distance (nth bodies i) (* (pref x 0) (tref qs 7)) (* (pref y 0) (tref qs 7))))
       (if (< id d)
        (begin
        (set! d id)
        (set! closestBody i))))
      (if (< d -1.0)
        (begin
        (pset! x 0 (* (pref x 0) (tref qs 7)))
        (pset! y 0 (* (pref y 0) (tref qs 7)))
        (closestSurfacePoint (nth bodies closestBody) x y)
        (distanceNormal (nth bodies closestBody) nx ny (pref x 0) (pref y 0))
        (pset! x 0 (- (pref x 0) (* (pref nx 0) (tref qs 7))))
        (pset! y 0 (- (pref y 0) (* (pref ny 0) (tref qs 7))))
        (pset! x 0 (/ (pref x 0) (tref qs 7)))
        (pset! y 0 (/ (pref y 0) (tref qs 7)))))
        void)))

(bind-func rungeKutta3
  (lambda (qs:ParticleQuantities* xp:double* yp:double* timestep u:FluidQuantity* v:FluidQuantity*)
    (let ((hx (tref qs 7)) (x (pref xp 0)) (y (pref yp 0))
      (firstU (/ (lerp u x y) hx))
      (firstV (/ (lerp v x y) hx))
        (midX (+ x (* 0.5 timestep firstU)))
        (midY (+ y (* 0.5 timestep firstV)))
        (midU (/ (lerp u midX midY) hx))
        (midV (/ (lerp v midX midY) hx))
            (lastX (+ x (* 0.75 timestep midU)))
            (lastY (+ y (* 0.75 timestep midV)))
            (lastU (lerp u lastX lastY))
            (lastV (lerp v lastX lastY)))
                  (pset! xp 0 (+ x (* timestep (+ (* (/ 2. 9.) firstU) (* (/ 3. 9.) midU) (* (/ 4. 9.) lastU)))))
                  (pset! yp 0 (+ y (* timestep (+ (* (/ 2. 9.) firstV) (* (/ 3. 9.) midV) (* (/ 4. 9.) lastV)))))
                  void)))

(bind-func addQuantity
  (lambda (qs:ParticleQuantities* fq:FluidQuantity*)
    (let ((maxParticles (tref qs 4))
          (property:double* (alloc maxParticles))
          (properties:List{double*}* (tref qs 13)) (quantities:List{FluidQuantity*}* (tref qs 14)))
      (tset! qs 13 (cons property properties))
      (tset! qs 14 (cons fq quantities)))))

(bind-func gridToParticles
  (lambda (qs:ParticleQuantities* alpha)
    (let ((t:i64 0) (i:i32 0) (quantities (tref qs 14)) (properties (tref qs 13)))
      (dotimes (t (length quantities))
        (dotimes (i (tref qs 3))
          (let ((property (nth properties t)))
          (pset! property i (* (pref property i) (- 1.0 alpha)))
          (pset! property i (+ (pref property i) (lerp (nth quantities t) (pref (tref qs 11) i) (pref (tref qs 12) i)))))
          )))))

(bind-func particlesToGrid
  (lambda (qs:ParticleQuantities* alpha:double)
    (let ((t 0) (i:i32 0) (quantities (tref qs 14)) (properties (tref qs 13)))
      (dotimes (t (length quantities))

      (printf "fromParticles\n")
        (fromParticles (nth quantities t) (tref qs 9) (tref qs 3) (tref qs 11) (tref qs 12) (nth properties t))
      (printf "extrapolate\n")
        (extrapolate (nth quantities t)))


        (printf "countparticles\n")
        (countparticles qs)
        (printf "pruneParticles\n")
        (pruneParticles qs)
        (printf "seedParticles\n")
        (seedParticles qs)

        (printf "Particle count:%d\n" (tref qs 3))
        )))

(bind-func advect
  (lambda (qs:ParticleQuantities* timestep u:FluidQuantity* v:FluidQuantity*)
    (let ((i:i32 0) (posX:double* (tref qs 11)) (posY:double* (tref qs 12)))
      (dotimes (i (tref qs 3))
        (rungeKutta3 qs (pref-ptr posX i) (pref-ptr posY i) timestep u v)
        (backProject qs (pref-ptr posX i) (pref-ptr posY i))))))

(bind-type FluidSolver <FluidQuantity*,FluidQuantity*,FluidQuantity*,i32,i32,double,double,double*,double*,double*,double*,double*,double*,double*,double*,List{SolidBody*}*,FluidQuantity*,double,double,double,double,double*,double*,ParticleQuantities*,double}*>
  (constructor? . #f)
  "0 - density grid
  1 - u
  2 - v
  3 - width
  4 - height
  5 - grid cell height
  6 - gravity
  7 - right-hand side of pressure solve
  8 - pressure solution
  9 - auxiliary vector
  10 - search vector
  11 - preconditioner
  12 - matrix diagonal
  13 - matrix off-diagonals x
  14 - matrix off-diagonals y
  15 - Solid Bodies
  16 - temperature fluid quantity
  17 - density of air
  18 - density of soot
  19 - diffusion rate of heat
  20 - ambient temperature in K
  21 - uDensity
  22 - vDensity
  23 - ParticleQuantities
  24 - flip Alpha
  ")


(bind-func FluidSolver
  (lambda (w h cBodies rhoAir rhoSoot diffusion)
    (let ((hx (/ 1. (convert (min w h))))
          (fs:FluidSolver* (alloc))
          (d (FluidQuantity w h 0.5 0.5 hx))
          (u (FluidQuantity (+ w 1) h 0.0 0.5 hx))
          (v (FluidQuantity w (+ h 1) 0.5 0.0 hx))
          (r:double* (alloc (* w h)))
          (p:double* (alloc (* w h)))
          (z:double* (alloc (* w h)))
          (s:double* (alloc (* w h)))
          (aDiag:double* (alloc (* w h)))
          (aPlusX:double* (alloc (* w h)))
          (aPlusY:double* (alloc (* w h)))
          (precon:double* (alloc (* w h)))
          (t (FluidQuantity w h 0.5 0.5 hx))
          (tAmb 294.0)
          (g 9.81)
          (uDensity:double* (alloc (* (+ w 1) h)))
          (vDensity:double* (alloc (* w (+ h 1))))
          (qs (ParticleQuantities w h hx cBodies))
          (flipAlpha 0.001)
          (i:i32 0))
      (dotimes (i (* w h))
        (pset! (tref t 0) i tAmb))
      (addQuantity qs d)
      (addQuantity qs t)
      (addQuantity qs u)
      (addQuantity qs v)
      (gridToParticles qs 1.0)
      (tfill! fs d u v w h hx g r p z s aDiag aPlusX aPlusY precon cBodies t rhoAir rhoSoot diffusion tAmb uDensity vDensity qs flipAlpha)
      fs)))

(bind-func FluidSolver_h
  (lambda (w h cBodies rhoAir rhoSoot diffusion)
    (let ((hx (/ 1. (convert (min w h))))
          (fs:FluidSolver* (alloc))
          (d (FluidQuantity_h w h 0.5 0.5 hx))
          (u (FluidQuantity_h (+ w 1) h 0.0 0.5 hx))
          (v (FluidQuantity_h w (+ h 1) 0.5 0.0 hx))
          (r:double* (halloc (* w h)))
          (p:double* (halloc (* w h)))
          (z:double* (halloc (* w h)))
          (s:double* (halloc (* w h)))
          (aDiag:double* (halloc (* w h)))
          (aPlusX:double* (halloc (* w h)))
          (aPlusY:double* (halloc (* w h)))
          (precon:double* (halloc (* w h)))
          (t (FluidQuantity_h w h 0.5 0.5 hx))
          (tAmb 294.0)
          (g 9.81)
          (uDensity:double* (halloc (* (+ w 1) h)))
          (vDensity:double* (halloc (* w (+ h 1))))
          (qs (ParticleQuantities w h hx cBodies))
          (flipAlpha 0.001)
          (i:i32 0))
      (dotimes (i (* w h))
        (pset! (tref t 0) i tAmb))
      (addQuantity qs d)
      (addQuantity qs t)
      (addQuantity qs u)
      (addQuantity qs v)
      (gridToParticles qs 1.0)
      (tfill! fs d u v w h hx g r p z s aDiag aPlusX aPlusY precon cBodies t rhoAir rhoSoot diffusion tAmb uDensity vDensity qs flipAlpha)
      fs)))

(bind-func FluidSolver_free
  "free a halloc'ed FluidSolver created with FluidSolver_h"
  (lambda (fs:FluidSolver*)
    (FluidQuantity_free (tref fs 0))
    (FluidQuantity_free (tref fs 1))
    (FluidQuantity_free (tref fs 1))
    (free (tref fs 7))
    (free (tref fs 8))
    (free fs)))

(bind-func printinfouat
    (lambda (fs:FluidSolver*)
      (let ((x 0) (y 0) (d (tref fs 1)))
        (let ((src (tref d 0)) (w (tref fs 3)) (h (tref fs 4)) (a 0))
          (printf "u: \n")
          (while (< y h)
            (set! x 0)
            (while (< x w)
            (let ((k (at:[double,FluidQuantity*,i32,i32]* d x y)))
            (if (< 0.05 k)
            (begin
            (printf "x:%d y:%d idx:%d" x y (+ (* y w) x))
            (printf ":  %f |" k)
            (set! a (+ a 1))
            (if (= a 3)
            (begin
            (println )
            (set! a 0)))))
              (set! x (+ x 1))))
            (set! y (+ y 1)))
              (printf "----------------------\n")
              ))))

(bind-func printinfovat
    (lambda (fs:FluidSolver*)
      (let ((x 0) (y 0) (d (tref fs 2)))
        (let ((src (tref d 0)) (w (tref fs 3)) (h (tref fs 4)) (a 0))
          (printf "v: \n")
          (while (< y h)
            (set! x 0)
            (while (< x w)
            (let ((k (at:[double,FluidQuantity*,i32,i32]* d x y)))
            (if (> k 0.05)
            (begin
            (printf "x:%d y:%d idx:%d" x y (+ (* y w) x))
            (printf ":  %f |" (at:[double,FluidQuantity*,i32,i32]* d x y))
            (set! a (+ a 1))
            (if (= a 3)
            (begin
            (println )
            (set! a 0)))))
              (set! x (+ x 1))))
            (set! y (+ y 1)))
              (printf "----------------------\n")
              ))))

(bind-func printinfodat
    (lambda (fs:FluidSolver*)
      (let ((x 0) (y 0) (d (tref fs 0)))
        (let ((src (tref d 0)) (w (tref fs 3)) (h (tref fs 4)) (a 0))
          (printf "d: \n")
          (while (< y h)
            (set! x 0)
            (while (< x w)
            (let ((k (at:[double,FluidQuantity*,i32,i32]* d x y)))
            (if (< 0.05 k)
            (begin
            (printf "x:%d y:%d idx:%d" x y (+ (* y w) x))
            (printf ":  %f |" (at:[double,FluidQuantity*,i32,i32]* d x y))
            (set! a (+ a 1))
            (if (= a 3)
            (begin
            (println )
            (set! a 0)))))
              (set! x (+ x 1))))
            (set! y (+ y 1)))
              (printf "----------------------\n")
              ))))



;; accessor functions for pointers to the raw data

(bind-func fsd
  (lambda (fs:FluidSolver*)
    (tref (tref fs 0) 0)))

(bind-func fsu
  (lambda (fs:FluidSolver*)
    (tref (tref fs 1) 0)))

(bind-func fsv
  (lambda (fs:FluidSolver*)
    (tref (tref fs 2) 0)))

;; TODO. _src/_dst don't seem to be gettin set. should happen in either
;; addInFlows or in applyPressure - need to check if that's happening


(bind-func buildRhs
  "Builds the pressure right hand side as the negative divergence"
  (lambda (fs:FluidSolver*)
    (let ((scale (/ 1. (tref fs 5)))
          (x 0) (y 0) (idx 0)
          (d (tref fs 0)) (u (tref fs 1)) (v (tref fs 2))
          (w (tref fs 3)) (h (tref fs 4)) (hx (tref fs 5))
          (cell (tref fs 9)) (body (tref fs 10))
          (bodies (tref fs 15)) (r (tref fs 7)))

      (while (< y h)
        (set! x 0)
        (while (< x w)
          (if (= (pref (tref d 9) idx) CELL_FLUID)
            (begin
            (pset! r idx
                       (* -1. scale (- (+ (* (volume u (+ x 1) y) (at:[double,FluidQuantity*,i32,i32]* u (+ x 1) y))
                                          (* (volume v x (+ y 1)) (at:[double,FluidQuantity*,i32,i32]* v x (+ y 1))))
                                       (+ (* (volume u x y) (at:[double,FluidQuantity*,i32,i32]* u x y))
                                          (* (volume v x y) (at:[double,FluidQuantity*,i32,i32]* v x y))))))
            (let ((vol (volume d x y)))
              (if (not (null? bodies))
                (begin
                  (if (> x 0)
                    (pset! r idx (- (pref r idx) (* (- (volume u x y) vol) (velocityX (nth bodies 0) (* (convert x) hx) (* (+ (convert y) 0.5) hx))))))
                  (if (> y 0)
                    (pset! r idx (- (pref r idx) (* (- (volume v x y) vol) (velocityY (nth bodies 0) (* (+ (convert x) 0.5) hx) (* (convert y) hx))))))
                  (if (< x (- w 1))
                    (pset! r idx (+ (pref r idx) (* (- (volume u (+ x 1) y) vol) (velocityX (nth bodies 0) (* (+ (convert x) 1.) hx) (* (+ (convert y) 0.5) hx))))))
                  (if (< y (- h 1))
                    (pset! r idx (+ (pref r idx) (* (- (volume v x (+ y 1)) vol) (velocityY (nth bodies 0) (* (+ (convert x) 0.5) hx) (* (+ (convert y) 1.) hx))))))))))

          (pset! (tref fs 7) idx 0.))
          (set! x (+ x 1))
          (set! idx (+ idx 1)))
          (set! y (+ 1 y))))))

(bind-func computeDensities
  (lambda (fs:FluidSolver*)
    (let ((densityAir (tref fs 17)) (densitySoot (tref fs 18))
          (alpha (/ (- densitySoot densityAir) densityAir))
          (uDensity (tref fs 21)) (vDensity (tref fs 22))
          (x 0) (y 0) (w (tref fs 3)) (h (tref fs 4)) (density 0.0)
          (d (tref fs 0)) (u (tref fs 1)) (v (tref fs 2)) (t (tref fs 16))
          (a:i32 0) (b:i32 0))
          (dotimes (a (* (+ 1 w) h))
            (pset! uDensity a 0.0))
          (dotimes (b (* w (+ 1 h)))
            (pset! vDensity b 0.0))
          (dotimes (y h)
            (dotimes (x w)
              (set! density (/ (* densityAir (tref fs 20) (+ 1.0 (* alpha (at:[double,FluidQuantity*,i32,i32]* d x y)))) (at:[double,FluidQuantity*,i32,i32]* t x y)))
              (set! density (max density (* 0.05 densityAir)))
              (pset! uDensity (getidx u x y) (+ (pref uDensity (getidx u x y)) (* 0.5 density)))
              (pset! vDensity (getidx v x y) (+ (pref vDensity (getidx v x y)) (* 0.5 density)))
              (pset! uDensity (getidx u (+ 1 x) y) (+ (pref uDensity (getidx u (+ 1 x) y)) (* 0.5 density)))
              (pset! vDensity (getidx v x (+ y 1)) (+ (pref vDensity (getidx v x (+ y 1))) (* 0.5 density))))
              ))))

(bind-func buildPressureMatrix
  (lambda (fs:FluidSolver* timestep)
    (let ((scale (/ timestep (* (tref fs 17) (tref fs 5) (tref fs 5)))) (factor 0.)
          (y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4)) (a:i32 0) (d (tref fs 0))
          (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14))
           (u (tref fs 1)) (v (tref fs 2)) (uDensity (tref fs 21)) (vDensity (tref fs 22)))

      (dotimes (a (* w h))
        (pset! aDiag a 0.)
        (pset! aPlusX a 0.)
        (pset! aPlusY a 0.))

      (dotimes (y h)
        (dotimes (x w)
        (if (= (pref (tref d 9) idx) CELL_FLUID)
          (begin
            (if (and (< x (- w 1)) (= (pref (tref d 9) (+ idx 1)) CELL_FLUID))
              (begin
              (set! factor (/ (* scale (volume u (+ x 1) y)) (pref uDensity (getidx u (+ 1 x) y))))
              (pset! aDiag idx (+ (pref aDiag idx) factor))
              (pset! aDiag (+ idx 1) (+ (pref aDiag (+ 1 idx)) factor))
              (pset! aPlusX idx (* -1. factor))))
            (if (and (< y (- h 1)) (= (pref (tref d 9) (+ idx w)) CELL_FLUID))
              (begin
              (set! factor (/ (* scale (volume v x (+ y 1))) (pref vDensity (getidx u x (+ 1 y)))))
              (pset! aDiag idx (+ (pref aDiag idx) factor))
              (pset! aDiag (+ idx w) (+ (pref aDiag (+ w idx)) factor))
              (pset! aPlusY idx (* -1. factor))))))
          (set! idx (+ idx 1))
          )))))

(bind-func buildHeatDiffusionMatrix
  (lambda (fs:FluidSolver* timestep)
    (let ((i:i32 0) (w (tref fs 3)) (h (tref fs 4))
          (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14))
          (d (tref fs 0)) (cell (tref d 9)) (scale (/ (* (tref fs 19) timestep) (* (tref fs 5) (tref fs 5))))
          (x 0) (y 0) (idx:i32 0))
      (dotimes (i (* w h))
        (pset! aDiag i 1.0)
        (pset! aPlusX i 0.0)
        (pset! aPlusY i 0.0))
        (dotimes (y h)
          (dotimes (x w)
            (if (= CELL_FLUID (pref cell idx))
              (begin
                (if (and (< x (- w 1)) (= (pref cell (+ 1 idx)) CELL_FLUID))
                  (begin
                    (pset! aDiag idx (+ (pref aDiag idx) scale))
                    (pset! aDiag (+ idx 1) (+ (pref aDiag (+ idx 1)) scale))
                    (pset! aPlusX idx (* -1. scale))))
                (if (and (< y (- h 1)) (= (pref cell (+ w idx)) CELL_FLUID))
                  (begin
                    (pset! aDiag idx (+ (pref aDiag idx) scale))
                    (pset! aDiag (+ idx w) (+ (pref aDiag (+ idx w)) scale))
                    (pset! aPlusY idx (* -1. scale))))
                ))
              (set! idx (+ 1 idx))))
        )))

(bind-func buildPreconditioner
  (lambda (fs:FluidSolver*)
    (let ((tau 0.97) (sigma 0.25)
          (y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4)) (d (tref fs 0))
          (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14)) (precon (tref fs 11)))
      (dotimes (y h)
        (dotimes (x w)
        (if (= (pref (tref d 9) idx) CELL_FLUID)
          (begin
          (let ((e (pref aDiag idx)))
            (if (and (> x 0) (= (pref (tref d 9) (- idx 1)) CELL_FLUID))
              (begin
                (let ((px (* (pref aPlusX (- idx 1)) (pref precon (- idx 1))))
                      (py (* (pref aPlusY (- idx 1)) (pref precon (- idx 1)))))
                    (set! e (- e (+ (* px px) (* tau px py)))))))
            (if (and (> y 0) (= (pref (tref d 9) (- idx w)) CELL_FLUID))
              (begin
                (let ((px (* (pref aPlusX (- idx w)) (pref precon (- idx w))))
                      (py (* (pref aPlusY (- idx w)) (pref precon (- idx w)))))
                    (set! e (- e (+ (* py py) (* tau px py)))))))

            (if (< e (* sigma (pref aDiag idx)))
              (set! e (pref aDiag idx)))

            (pset! precon idx (/ 1. (sqrt e))))))
            (set! idx (+ idx 1)))))))

(bind-func applyPreconditioner
  (lambda (fs:FluidSolver* dst:double* a:double*)
    (let ((y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4)) (d (tref fs 0))
    (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14)) (precon (tref fs 11)))
      (dotimes (y h)
        (dotimes (x w)
          (if (= (pref (tref d 9) idx) CELL_FLUID)
            (begin
            (let ((t (pref a idx)))
              (if (and (> x 0) (= (pref (tref d 9) (- idx 1)) CELL_FLUID))
                (set! t (- t (* (pref aPlusX (- idx 1)) (pref precon (- idx 1)) (pref dst (- idx 1))))))

              (if (and (> y 0) (= (pref (tref d 9) (- idx w)) CELL_FLUID))
                (set! t (- t (* (pref aPlusY (- idx w)) (pref precon (- idx w)) (pref dst (- idx w))))))

              (pset! dst idx (* t (pref precon idx))))))
              (set! idx (+ idx 1))))

      (set! y (- h 1))
      (set! idx (- (* w h) 1))

      (while (>= y 0)
      (set! x (- w 1))
        (while (>= x 0)
          (if (= (pref (tref d 9) idx) CELL_FLUID)
          (begin
          (let ((t (pref dst idx)))
          (if (and (< x (- w 1)) (= (pref (tref d 9) (+ idx 1)) CELL_FLUID))
              (set! t (- t (* (pref aPlusX idx) (pref precon idx) (pref dst (+ 1 idx))))))
          (if (and (< y (- h 1)) (= (pref (tref d 9) (+ idx w)) CELL_FLUID))
              (set! t (- t (* (pref aPlusY idx) (pref precon idx) (pref dst (+ w idx))))))

        (pset! dst idx (* t (pref precon idx))))))

        (set! x (- x 1))
        (set! idx (- idx 1)))
        (set! y (- y 1))))))

(bind-func dotProduct
  (lambda (fs:FluidSolver* a:double* b:double*)
    (let ((result 0.0) (i:i32 0) (w (tref fs 3)) (h (tref fs 4)))
      (dotimes (i (* w h))
        (set! result (+ result (* (pref a i) (pref b i)))))
      result)))

(bind-func matrixVectorProduct
  (lambda (fs:FluidSolver* dst:double* b:double*)
    (let ((y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4))
          (aDiag (tref fs 12)) (aPlusX (tref fs 13)) (aPlusY (tref fs 14)) (precon (tref fs 11)))
      (dotimes (y h)
        (dotimes (x w)
          (let ((t (* (pref aDiag idx) (pref b idx))))
            (if (> x 0)
                (set! t (+ t (* (pref aPlusX (- idx 1)) (pref b (- idx 1))))))
            (if (> y 0)
                (set! t (+ t (* (pref aPlusY (- idx w)) (pref b (- idx w))))))
            (if (< x (- w 1))
                (set! t (+ t (* (pref aPlusX idx) (pref b (+ idx 1))))))
            (if (< y (- h 1))
                (set! t (+ t (* (pref aPlusY idx) (pref b (+ idx w))))))

            (pset! dst idx t)
            (set! idx (+ idx 1))))))))

(bind-func scaledAdd
  (lambda (fs:FluidSolver* dst:double* a:double* b:double* s:double)
    (let ((i:i32 0) (w (tref fs 3)) (h (tref fs 4))
    (d (tref fs 0)) (cell (tref d 9)))
      (dotimes (i (* w h))
      (if (= (pref cell i) CELL_FLUID)
        (pset! dst i (+ (pref a i) (* (pref b i ) s))))))))

(bind-func infinityNorm
  (lambda (fs:FluidSolver* a:double*)
    (let ((maxA 0.0) (i:i32 0) (w (tref fs 3)) (h (tref fs 4))
          (d (tref fs 0)) (cell (tref d 9)))
      (dotimes (i (* w h))
        (if (= (pref cell i) CELL_FLUID)
        (set! maxA (max maxA (fabs (pref a i))))))
        maxA)))

(bind-func project
  "Performs the pressure solve using Gauss-Seidel.
  The solver will run as long as it takes to get the relative error below
  a threshold, but will never exceed `limit' iterations"
  (lambda (fs:FluidSolver* limit:i32)
    (let ((maxDelta:double 1.)
          (iter:i32 0) (i:i32 0)
          (x:i32 0) (y:i32 0) (idx:i32 0)
          (w (tref fs 3)) (h (tref fs 4))
          (p (tref fs 8))
          (z (tref fs 9))
          (r (tref fs 7))
          (s (tref fs 10))
          (maxError (infinityNorm fs r)) (sigma 0.))
      (applyPreconditioner fs z r)
      (dotimes (i (* w h))
        (pset! s i (pref z i))
        (pset! p i 0.))
      (set! sigma (dotProduct fs z r))
      (while (and (> maxError 1e-5) (< iter limit))
        (matrixVectorProduct fs z s)
        (let ((alpha (/ sigma (dotProduct fs z s))))
          (scaledAdd fs p p s alpha)
          (scaledAdd fs r r z (* -1. alpha))
          (set! maxError (infinityNorm fs r))
          (if (> maxError 1e-5)
              (begin
                (applyPreconditioner fs z r)
                (let ((sigmaNew (dotProduct fs z r)))
                  (scaledAdd fs s z s (/ sigmaNew sigma))
                  (set! sigma sigmaNew))
                (set! iter (+ iter 1))))))
          (printf "Exiting solver after %d iterations, maximum error is %f\n" iter maxError))))

(bind-func applyPressure
  "Applies the computed pressure to the velocity field"
  (lambda (fs:FluidSolver* timestep)
    (let ((scale (/ timestep (* (tref fs 17) (tref fs 5))))
          (x 0) (y 0) (idx 0)
          (w (tref fs 3)) (h (tref fs 4))
          (d (tref fs 0))
          (u (tref fs 1))
          (v (tref fs 2))
          (p (tref fs 8))
          (uDensity (tref fs 21)) (vDensity (tref fs 22)))
      (dotimes (y h)
        (dotimes (x w)
          (if (= (pref (tref d 9) idx) CELL_FLUID)
            (begin
            ;; this is a bit messy - we could get around it by just
            ;; using different names for the ref/val `at' function
            ;; instead of using polymorphism
            (pset! (at:[double*,FluidQuantity*,i32,i32]* u x y) 0
                (- (at:[double,FluidQuantity*,i32,i32]* u x y) (/ (* scale (pref p idx)) (pref uDensity (getidx u x y)))))
            (pset! (at:[double*,FluidQuantity*,i32,i32]* u (+ x 1) y) 0
                (+ (at:[double,FluidQuantity*,i32,i32]* u (+ x 1) y) (/ (* scale (pref p idx)) (pref uDensity (getidx u (+ x 1) y)))))
            (pset! (at:[double*,FluidQuantity*,i32,i32]* v x y) 0
                (- (at:[double,FluidQuantity*,i32,i32]* v x y) (/ (* scale (pref p idx)) (pref vDensity (getidx v x y)))))
            (pset! (at:[double*,FluidQuantity*,i32,i32]* v x (+ y 1)) 0
                (+ (at:[double,FluidQuantity*,i32,i32]* v x (+ y 1)) (/ (* scale (pref p idx)) (pref vDensity (getidx v x (+ y 1))))))))
          (set! idx (+ idx 1)))))))

(bind-func addBuoyancy
  (lambda (fs:FluidSolver* timestep)
    (let ((alpha (/ (- (tref fs 18) (tref fs 17)) (tref fs 17)))
          (y 0) (x 0) (w (tref fs 3)) (h (tref fs 4))
          (d (tref fs 0)) (t (tref fs 16))
          (buoyancy 0.) (v (tref fs 2))
          (tAmb (tref fs 20)) (g (tref fs 6)))
      (dotimes (y h)
        (dotimes (x w)
          (set! buoyancy (* timestep g (- (* alpha (at:[double,FluidQuantity*,i32,i32]* d x y))
                                              (/ (- (at:[double,FluidQuantity*,i32,i32]* t x y) tAmb) tAmb))))
          (pset! (at:[double*,FluidQuantity*,i32,i32]* v x y) 0
                          (+ (at:[double,FluidQuantity*,i32,i32]* v x y) (* buoyancy 0.5)))
          (pset! (at:[double*,FluidQuantity*,i32,i32]* v x (+ 1 y)) 0
                          (+ (at:[double,FluidQuantity*,i32,i32]* v x (+ 1 y)) (* buoyancy 0.5)))
          )))))

(bind-func setBoundaryCondition
  (lambda (fs:FluidSolver*)
    (let ((d (tref fs 0)) (cell (tref d 9)) (body (tref d 10)) (u (tref fs 1)) (hx (tref fs 5))
          (y 0) (x 0) (idx 0) (w (tref fs 3)) (h (tref fs 4)) (v (tref fs 2)) (bodies (tref fs 15))
          (b null))
      (dotimes (y h)
        (dotimes (x w)
          (if (= (pref (tref d 9) idx) CELL_SOLID)
              (begin
                (set! b (nth bodies (convert (pref body idx))))
                (pset! (at:[double*,FluidQuantity*,i32,i32]* u x y)
                       0 (velocityX b (* (convert x) hx) (* (+ (convert y) 0.5) hx)))
                (pset! (at:[double*,FluidQuantity*,i32,i32]* v x y)
                       0 (velocityX b (* (+ (convert x) 0.5) hx) (* (convert y) hx)))
                (pset! (at:[double*,FluidQuantity*,i32,i32]* u (+ 1 x) y)
                       0 (velocityX b (* (+ (convert x) 1.0) hx) (* (+ (convert y) 0.5) hx)))
                (pset! (at:[double*,FluidQuantity*,i32,i32]* v x (+ 1 y))
                       0 (velocityX b (* (+ (convert x) 0.5) hx) (* (+ (convert y) 1.0) hx)))))
          (set! idx (+ 1 idx))))
      (set! x 0)
      (set! y 0)
      (while (< y h)
        (pset! (at:[double*,FluidQuantity*,i32,i32]* u 0 y) 0 0.)
        (pset! (at:[double*,FluidQuantity*,i32,i32]* u w y) 0 0.)
        (set! y (+ 1 y)))
      (while (< x w)
        (pset! (at:[double*,FluidQuantity*,i32,i32]* v x 0) 0 0.)
        (pset! (at:[double*,FluidQuantity*,i32,i32]* v x h) 0 0.)
        (set! x (+ 1 x))))))

(bind-func addInFlow
  "Set density and x/y velocity in given rectangle to d/u/v, respectively"
  (lambda (fs:FluidSolver* x y w h d t u v)
    (addInFlow:[void,FluidQuantity*,double,double,double,double,double]*
     (tref fs 0) x y (+ x w) (+ y h) d)
    (addInFlow:[void,FluidQuantity*,double,double,double,double,double]*
     (tref fs 16) x y (+ x w) (+ y h) t)
    (addInFlow:[void,FluidQuantity*,double,double,double,double,double]*
     (tref fs 1) x y (+ x w) (+ y h) u)
    (addInFlow:[void,FluidQuantity*,double,double,double,double,double]*
     (tref fs 2) x y (+ x w) (+ y h) v)
     ))

(bind-func updatefs
  (lambda (fs:FluidSolver* timestep:double)
  (let ((i:i32 0) (h (tref fs 4)) (w (tref fs 3)) (x:i32 0) (y:i32 0) (idx:i32 0)
        (d (tref fs 0)) (u (tref fs 1)) (v (tref fs 2)) (t (tref fs 16))
        (bodies (tref fs 15)) (qs (tref fs 23)) (flipAlpha (tref fs 24)))
    (printf "fillSolidFields\n")
    (fillSolidFields d bodies)
    (fillSolidFields t bodies)
    (fillSolidFields u bodies)
    (fillSolidFields v bodies)
    (printf "particlesToGrid\n")
    (particlesToGrid qs 1.0)
    (printf "copy\n")
    (copy d)
    (copy t)
    (copy u)
    (copy v)

    (printf "addInFlow\n")
    (addInFlow fs 0.45 0.2 0.2 0.05 1.0 (tref fs 20) 0.0 0.0)

    (dotimes (i (* w h))
      (pset! (tref fs 7) i (pref (tref t 0) i)))
    (printf "buildHeatDiffusionMatrix\n")
    (buildHeatDiffusionMatrix fs timestep)
    (buildPreconditioner fs)
    (project fs 2000)
    (set! i 0)
    (dotimes (i (* w h))
      (pset! (tref t 0) i (pref (tref fs 8) i)))
    (extrapolate t)
    (addBuoyancy fs timestep)
    (setBoundaryCondition fs)
    (buildRhs fs)
    (computeDensities fs)
    (buildPressureMatrix fs timestep)
    (buildPreconditioner fs)
    (project fs 2000)
    (applyPressure fs timestep)

    (extrapolate u)
    (extrapolate d)
    (extrapolate v)
    (setBoundaryCondition fs)

    (printf "diff\n")
    (diff d flipAlpha)
    (diff t flipAlpha)
    (diff u flipAlpha)
    (diff v flipAlpha)

    (printf "gridToParticles\n")
    (gridToParticles qs flipAlpha)

    (printf "undiff\n")
    (undiff d flipAlpha)
    (undiff t flipAlpha)
    (undiff u flipAlpha)
    (undiff v flipAlpha)

    (printf "advect\n")
    (advect qs timestep u v)
    )))


(bind-func maxTimestep
  "Returns the maximum allowed timestep. Note that the actual timestep
    taken should usually be much below this to ensure accurate
    simulation - just never above."
      (lambda (fs:FluidSolver*)
        (let ((maxVelocity 0.)
              (x 0) (y 0)
              (u 0.) (v 0.))
          (dotimes (y (tref fs 4))
            (dotimes (x (tref fs 3))
              (set! u (lerp (tref fs 1) (+ (convert x) .5) (+ (convert y) .5)))
              (set! u (lerp (tref fs 2) (+ (convert x) .5) (+ (convert y) .5)))
              (set! maxVelocity (max maxVelocity (sqrt (+ (* u u) (* v v)))))))
          ;; Fluid should not flow more than two grid cells per iteration,
          ;; so we clamp to sensible maximum value in case of very small
          ;; velocities
          (min (/ (* 2. (tref fs 5)) maxVelocity) 1.0))))
